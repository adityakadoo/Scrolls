<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.101.0"><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico><title>Automata Theory - Scrolls</title><meta name=keywords content="Computer-Science"><meta property="og:title" content="Automata Theory"><meta name=twitter:title content="Automata Theory"><meta property="og:type" content="article"><meta property="og:url" content="https://adityakadoo.github.io/Scrolls/courses/automata_theory/"><meta property="og:description" content="Resources Hopcrot-Motwani-Ullman Central Concepts Alphabets Alphabet $ (\Sigma) $ An alphabet is a finite nonempty set of symbols. $ \Sigma= \{1, 0\} $ $ \Sigma = \{a,b,&mldr;,z\}$ Strings String $(w)$ A string is a finite sequence of symbols chosen from $ \Sigma $. Empty String Empty String $(\epsilon)$ The empty string is a string with zero symbols. Length of a String $|w|=\#$ Symbols in $w$
$|\epsilon|=0$
Powers of Alphabets $\Sigma^k=\{w:|w|=k\}$ $\Sigma^+=\Sigma^1\cup\Sigma^2\cup&mldr;$ $\Sigma^*=\Sigma^+\cup\{\epsilon\}$ $\Sigma^0= \{\epsilon\}$"><meta name=twitter:description content="Resources Hopcrot-Motwani-Ullman Central Concepts Alphabets Alphabet $ (\Sigma) $ An alphabet is a finite nonempty set of symbols. $ \Sigma= \{1, 0\} $ $ \Sigma = \{a,b,&mldr;,z\}$ Strings String $(w)$ A string is a finite sequence of symbols chosen from $ \Sigma $. Empty String Empty String $(\epsilon)$ The empty string is a string with zero symbols. Length of a String $|w|=\#$ Symbols in $w$
$|\epsilon|=0$
Powers of Alphabets $\Sigma^k=\{w:|w|=k\}$ $\Sigma^+=\Sigma^1\cup\Sigma^2\cup&mldr;$ $\Sigma^*=\Sigma^+\cup\{\epsilon\}$ $\Sigma^0= \{\epsilon\}$"><meta name=twitter:card content="summary"><meta property="article:published_time" content="2022-08-19T17:00:34+05:30"><meta property="article:modified_time" content="2022-08-19T17:00:34+05:30"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://adityakadoo.github.io/Scrolls/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://adityakadoo.github.io/Scrolls/>Scrolls</a></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://adityakadoo.github.io/Scrolls/courses/automata_theory/>Automata Theory</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-08-19</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/computer-science>Computer-Science</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=resources>Resources</h2><ul><li><h3 id=hopcrot-motwani-ullmanhttpswww-2dcubaarstaffbecherhopcroft-motwani-ullman-2001pdf><a href=https://www-2.dc.uba.ar/staff/becher/Hopcroft-Motwani-Ullman-2001.pdf target=_blank>Hopcrot-Motwani-Ullman</a></h3></li></ul><h2 id=central-concepts>Central Concepts</h2><h3 id=alphabets>Alphabets</h3><dl><dt>Alphabet $ (\Sigma) $</dt><dd>An <em><strong>alphabet</strong></em> is a finite nonempty set of symbols.</dd></dl><ol><li>$ \Sigma= \{1, 0\} $</li><li>$ \Sigma = \{a,b,&mldr;,z\}$</li></ol><h3 id=strings>Strings</h3><dl><dt>String $(w)$</dt><dd>A <em><strong>string</strong></em> is a finite sequence of symbols chosen from $ \Sigma $.</dd></dl><h4 id=empty-string>Empty String</h4><dl><dt>Empty String $(\epsilon)$</dt><dd>The <em><strong>empty string</strong></em> is a string with zero symbols.</dd></dl><h4 id=length-of-a-string>Length of a String</h4><p>$|w|=\#$ Symbols in $w$</p><blockquote><p>$|\epsilon|=0$</p></blockquote><h4 id=powers-of-alphabets>Powers of Alphabets</h4><ul><li>$\Sigma^k=\{w:|w|=k\}$</li><li>$\Sigma^+=\Sigma^1\cup\Sigma^2\cup&mldr;$</li><li>$\Sigma^*=\Sigma^+\cup\{\epsilon\}$</li></ul><blockquote><p>$\Sigma^0= \{\epsilon\}$</p></blockquote><h4 id=concatenation-of-strings>Concatenation of Strings</h4><p>For strings $w_1$ and $w_2$, their <em><strong>concatenation</strong></em> is $w_1w_2$.</p><blockquote><p>$|w_1w_2| = |w_1|+|w_2|$</p></blockquote><h3 id=languages>Languages</h3><dl><dt>Language $(L)$</dt><dd>A <em><strong>language</strong></em> over $\Sigma$ is basically $L\sube\Sigma$.</dd></dl><blockquote><p>A common way on defining languages is to use set-builder form as,
$\{w\in\Sigma:$ something about $w\}$.</p></blockquote><h4 id=empty-language>Empty Language</h4><dl><dt>Empty Language $(\empty)$</dt><dd>The <em><strong>empty language</strong></em> contains no words.</dd></dl><blockquote><p>$\empty\ne\{\epsilon\}$</p></blockquote><h3 id=problems>Problems</h3><dl><dt>Problem</dt><dd>Any <em><strong>problem</strong></em> is, given a $w$ in $\Sigma^*$, decide whether or not $w$ is in $L$.</dd></dl><blockquote><p>If testing membership in $L_X$ is hard, then compiling programs in programming language $X$ is hard.</p></blockquote><h2 id=finite-state-automaton>Finite State Automaton</h2><h3 id=deterministic-finite-automaton>Deterministic Finite Automaton</h3><p>A <em><strong>deterministic finite automaton</strong></em> $( A(Q,\Sigma,\delta,q_0,F) )$ consists of:</p><ol><li>A finite set of <em>states</em> $(Q)$.</li><li>A finite set of <em>input symbols</em> $(\Sigma)$.</li><li>A <em>transition function</em> $(\delta:Q\times\Sigma\rightarrow Q)$</li><li>A <em>start state</em> $(q_0\in Q)$</li><li>A set of <em>final states</em> $F\sube Q$</li></ol><h4 id=transition-diagram>Transition diagram</h4><p>A <em><strong>transition diagram</strong></em> for a $A$ is a graph $G(V,E)$ defined as follows:-</p><ol><li>$V=\{q:q\in Q\}$</li><li>$E=\{q_1\xrightarrow{a}q_2:a\in\Sigma\text{ and }\delta(q_1,a)=q_2\}$</li><li>An arrow pointing into $q_0$.</li><li>All nodes in $F$ are denoted with double circle.</li></ol><h4 id=extended-transition-function>Extended transition function</h4><p>The <em><strong>extended transition function</strong></em> $(\hat\delta:Q\times\Sigma^*\rightarrow Q)$ can be defined inductively as:</p><ul><li><em>Basis</em>: $\hat\delta(q,\epsilon)=q$</li><li><em>Induction</em>: $\hat\delta(q,w)=\delta(\hat\delta(q,w[:-1]),w[-1])$</li></ul><h4 id=language-of-a-dfa>Language of a DFA</h4><p>The <em><strong>language</strong></em> of DFA $(L(A))$ is defined as,
$$
L(A)=\{w\in\Sigma:\hat\delta(q_0,w)\in F\}
$$</p><h3 id=nondeterministic-finite-automaton>Nondeterministic Finite Automaton</h3><p>A <em><strong>non-deterministic finite automaton</strong></em> $( A(Q,\Sigma,\delta,q_0,F) )$ consists of:</p><ol><li>A finite set of <em>states</em> $(Q)$.</li><li>A finite set of <em>input symbols</em> $(\Sigma)$.</li><li>A <em>transition function</em> $(\delta:Q\times\Sigma\rightarrow P(Q))$</li><li>A <em>start state</em> $(q_0\in Q)$</li><li>A set of <em>final states</em> $F\sube Q$</li></ol><blockquote><p>$P(S)=\{A:A\sube S\}$</p></blockquote><h4 id=extended-transition-function-1>Extended transition function</h4><p>The <em><strong>extended transition function</strong></em> $(\hat\delta:Q\times\Sigma^*\rightarrow P(Q))$ can be defined inductively as:</p><ul><li><em>Basis</em>: $\hat\delta(q,\epsilon)=\{q\}$</li><li><em>Induction</em>: $\hat\delta(q,w)=\bigcup_{p\in \hat\delta(q,w[:-1])}\delta(p,w[-1])$</li></ul><h4 id=language-of-an-nfa>Language of an NFA</h4><p>The <em><strong>language</strong></em> of NFA $(L(A))$ is defined as,
$$
L(A)=\{w\in\Sigma:\hat\delta(q_0,w)\cap F\ne\empty\}
$$</p><h4 id=equivalence-of-dfa-and-nfa>Equivalence of DFA and NFA</h4><p>Given an NFA $(N=\{Q_N,\Sigma,\delta_N,q_0,F_N\})$ it can be converted to a DFA $D=\{Q_D,\Sigma,\delta_D,\{q_0\},F_D\}$ such that $L(D)=L(N)$ using <em><strong>subset construction</strong></em> method.</p><ol><li>$Q_D=P(Q_N)$</li><li>$F_D=\{S\sube Q_N:S\cap F_N\ne\empty\}$</li><li>$\delta_D:P(Q_N)\times\Sigma\rightarrow P(Q_N)$ is defined as,
$$
\delta_D(S,a)=\bigcup_{p\in S}\delta_N(p,a)
$$</li></ol><h5 id=theorem--ldln-ie-forall-winsigma-hatdelta_dq_0whatdelta_nq_0w><strong>Theorem</strong> : $L(D)=L(N)$ i.e. $\forall w\in\Sigma,\\ \hat\delta_D(\{q_0\},w)=\hat\delta_N(q_0,w)$</h5><p>Proof</p><ul><li><em>Basis</em>: For $w=\epsilon,\\ \hat\delta_D(\{q_0\},w)=\{q_0\}$ and $\hat\delta_N(q_0,w)=\{q_0\}$</li><li><em>Induction</em>: As $\hat\delta_N(q_0,w[:-1])=\hat\delta_D(\{q_0\},w[:-1])$
$$
\hat\delta_N(q_0,w)=\bigcup_{p\in\hat\delta_N(q_0,w[:-1])}\delta_N(p,w[-1])
$$
$$
\hat\delta_D(\{q_0\},w)=\delta_D(\hat\delta_D(\{q_0\},w[:-1]),w[-1])=\bigcup_{p\in\hat\delta_D(\{q_0\},w[:-1])}\delta_N(p,w[-1])
$$
$$
\therefore\hat\delta_D(\{q_0\},w)=\hat\delta_N(q_0,w)
$$</li></ul><h5 id=theorem--a-language-l-is-accepted-by-some-dfa-iff-l-is-accepted-by-some-nfa><strong>Theorem</strong> : A language $L$ is accepted by some DFA iff $L$ is accepted by some NFA.</h5><blockquote><p>A bad case for subset construction is $L=\{w\in\{1,0\}^*:w[-n]=1\}$</p></blockquote><h3 id=finite-automaton-with-epsilon-transition>Finite Automaton with $\epsilon$-transition</h3><p>A <em><strong>non-deterministic finite automaton with $\epsilon$-transitions</strong></em> $( A(Q,\Sigma,\delta,q_0,F) )$ is defined similar to the NFA with only difference in $\delta:Q\times\Sigma\cup\{\epsilon\}\rightarrow P(Q)$.</p><h4 id=epsilon-closure>Epsilon Closure</h4><ul><li><em>Basis</em>: $q\in\text{Ecl}(q)$</li><li><em>Induction</em>: If $p\in\text{Ecl}(q)$ and $r\in\delta(p,\epsilon)$ then $r\in\text{Ecl}(q)$</li></ul><h4 id=extended-transition-function-2>Extended Transition Function</h4><ul><li><em>Basis</em>: $\hat\delta(q,\epsilon)=\text{Ecl}(q)$</li><li><em>Induction</em>: $$\hat\delta(q,w)=\bigcup_{r\in\bigcup_{p\in\hat\delta(q,w[:-1])}\delta(p,w[-1])}\text{Ecl}(r)$$</li></ul><h4 id=eliminating-epsilon-transitions>Eliminating $\epsilon$-transitions</h4><p>Given an $\epsilon$-NFA $(E=\{Q_E,\Sigma,\delta_E,q_0,F_E\})$ it can be converted to a DFA $D=\{Q_D,\Sigma,\delta_D,\{q_D\},F_D\}$ such that $L(D)=L(E)$ as follows,</p><ol><li>$Q_D=P(Q_E)$</li><li>$q_D=\text{Ecl}(q_0)$</li><li>$F_D=\{S:S\in Q_D$ and $S\cap F_E\ne\empty\}$</li><li>$\delta_D:Q_D\times\Sigma$ is defined as follows,
$$
\delta_D(S,a)=\bigcup_{r\in\bigcup_{p\in S}\delta_E(p,a)}\text{Ecl}(r)
$$</li></ol><h5 id=theorem--a-language-l-is-accepted-by-some-epsilon-nfa-iff-l-is-accepted-by-some-dfa><strong>Theorem</strong> : A language $L$ is accepted by some $\epsilon$-NFA iff $L$ is accepted by some DFA.</h5><p>Proof</p><ul><li><em>Basis</em>: Since $\hat\delta_E(q_0, \epsilon)=\text{Ecl}(q_0)$ and $\hat\delta_D(q_D, \epsilon)=\hat\delta_D(\text{Ecl}(q_0),\epsilon)=\text{Ecl}(q_0)$, $\hat\delta_E(q_0, \epsilon) = \hat\delta_D(q_D, \epsilon)$</li><li><em>Induction</em>: As $\hat\delta_E(q_0, w[:-1])=\hat\delta_D(q_D,w[:-1])$ and,
$$
\hat\delta_E(q_0,w)=\bigcup_{r\in\bigcup_{p\in\hat\delta_E(q_0, w[:-1])}\delta_E(p,w[-1])}\text{Ecl}(r)
$$
and $\hat\delta_D(q_D,w)$ is defined in a similar way,
$$
\therefore\hat\delta_E(q_0, w)=\hat\delta_D(q_D,w)
$$</li></ul><h2 id=regular-expressions-and-languages>Regular Expressions and Languages</h2><h3 id=regular-expressions>Regular Expressions</h3><h4 id=operators-on-regular-languages>Operators on Regular Languages</h4><ol><li><p><em><strong>Union</strong></em>: The union of two languages $L$ and $M$ is defined as $L\cup M$.</p></li><li><p><em><strong>Concatenation</strong></em>: The concatenation of two languages $L$ and $M$ is defined as $LM=\{xy:x\in L,y\in M\}$.</p></li><li><p><em><strong>Kleene closure</strong></em>: The Kleene closure of a language $L$ is defined inductively as,</p><ul><li><p><em>Basis</em>: $\epsilon\in L^*$</p></li><li><p><em>Induction</em>: If $w\in L^*$ and $x\in L$ then, $wx\in L^*$</p></li></ul></li></ol><h4 id=building-regular-expressions>Building Regular-Expressions</h4><ul><li><em>Basis</em>: It contains 2 parts:<ol><li>The constants $\boldsymbol{\epsilon}$ and $\boldsymbol{\empty}$ are regular expressions such that $L(\boldsymbol{\epsilon})=\{\epsilon\}$ and $L(\boldsymbol{\empty})=\empty$.</li><li>Every symbol $\boldsymbol{a}$ such that $a\in\Sigma$ is a regular expression then $L(\boldsymbol{a})=\{a\}$</li></ol></li><li><em>Induction</em>: There are four parts for the induction step where $E$ and $F$ are regular expressions:<ol><li>$L(E+F)=L(E)\cup L(F)$</li><li>$L(EF)=L(E)L(F)$</li><li>$L(E^*)=(L(E))^*$</li><li>$L((E))=L(E)$</li></ol></li></ul><h4 id=precedence-of-regular-expression-operators>Precedence of Regular-Expression Operators</h4><blockquote><p>* &#187; . &#187; +</p></blockquote><h3 id=finite-automata-and-regular-expressions>Finite Automata and Regular-Expressions</h3><h4 id=from-dfa-to-regular-expressions>From DFA to Regular Expressions</h4><h5 id=theorem-if-lla-for-some-dfa-a-then-there-is-a-regular-expression-r-such-that-llr><strong>Theorem</strong>: If $L=L(A)$ for some DFA $A$, then there is a regular expression $R$ such that $L=L(R)$.</h5><p>Proof</p><p>Let the DFA have $n$ nodes each labelled with a number from $[1,n]$.</p><blockquote><p>$R_{ij}^{(k)}=\{w:\hat\delta(i,w)=j$ and $\forall t$ such that $0&lt;t&lt;|w|-1,\ \hat\delta(i,w[:t])\le k\}$</p></blockquote><ul><li><em>Basis</em>: Let $S=\{a:\delta(i,a)=j\}$. If $S=\empty$ then $R_{ij}^{(0)}=\empty$ else $R_{ij}^{(0)}=\sum_{a\in S}a$</li><li><em>Induction</em>:
$$
R_{ij}^{(k)}=R_{ij}^{(k-1)} + R_{ik}^{(k-1)}(R_{kk}^{(k-1)})^*R_{kj}^{(k-1)}
$$</li></ul><h4 id=coverting-regular-expressions-to-automata>Coverting Regular Expressions to Automata</h4><h5 id=theorem-every-language-accepted-by-a-regular-expression-is-also-accepted-by-a-finite-automaton><strong>Theorem</strong>: Every language accepted by a regular expression is also accepted by a finite automaton.</h5><p>Proof
Let $L=L(R)$ for some regular expression $R$. We show that $L=L(E)$ for some $\epsilon$-NFA $E$ with:</p><ol><li>Exactly on accepting state.</li><li>No arcs into the initial state.</li><li>No arcs out of the accepting state.</li></ol><ul><li><p><em>Basis</em>: For the 3 base cases:</p><ol><li>$$</li><li>$$</li><li>$$</li></ol></li><li><p><em>Induction</em>:</p><ol><li>$$</li><li>$$</li><li>$$</li></ol></li></ul><h3 id=algebraic-laws-for-regular-expressions>Algebraic Laws for Regular Expressions</h3><h4 id=associativity-and-commutativity>Associativity and Commutativity</h4><ul><li>$L+M=M+L$</li><li>$(L+M)+N=L+(M+N)$</li><li>$(LM)N$=$L(MN)$</li></ul><h4 id=identities-and-annihilators>Identities and Annihilators</h4><ul><li>$\empty+L=L+\empty=L$</li><li>$\epsilon L=L\epsilon=L$</li><li>$\empty L=L\empty=\empty$</li></ul><h4 id=distributive-laws>Distributive Laws</h4><ul><li>$L(M+N)=LM+LN$</li><li>$(M+N)L=ML+NL$</li></ul><h4 id=idempotent-law>Idempotent Law</h4><ul><li>$L+L=L$</li></ul><h4 id=laws-with-closure>Laws with Closure</h4><ul><li>$(L^*)^*=L^*$</li><li>$\empty^*=\epsilon$</li><li>$\epsilon^*=\epsilon$</li></ul><blockquote><p>$L^+=LL^*$</p></blockquote><ul><li>$L^*=L^++\epsilon$</li></ul><blockquote><p>$L?=\epsilon+L$</p></blockquote><ul><li>$(L^*M^*)^*=(L+M)^*$</li></ul><h2 id=properties-of-regular-languages>Properties of Regular Languages</h2><h3 id=pumping-lemma>Pumping Lemma</h3><h5 id=theorem-the-pumping-lemma-for-regular-languages-for-all-l-such-that-l-is-a-regular-language-there-exists-a-constant-n-such-that-for-all-wge-n-we-can-break-w-into-three-strings-wxyz-such-that><strong>Theorem</strong>: (<em>The pumping lemma for regular languages</em>) For all $L$ such that $L$ is a regular language, there exists a constant $n$ such that for all $|w|\ge n$ we can break $w$ into three strings, $w=xyz$, such that:</h5><h5 id=1-yneepsilon>1. $y\ne\epsilon$</h5><h5 id=2-xyle-n>2. $|xy|\le n$</h5><h5 id=3-forall-kge0xykzin-l>3. $\forall k\ge0,xy^kz\in L$</h5><p>Proof
Let $L=L(A)$ be a regular language for DFA $A$. Consider a $w$ such that $|w|\ge n$.
We define,
$$
S = \{p
_i:0\le i\le n,\hat\delta(q_0,w[:i]),\}
$$</p><p>As size of $S$ is n+1 there must be 2 $p_i$ and $p_j$ such that $p_i=p_j$. We can break $w$ as,</p><ol><li>$x=w[:i]$</li><li>$y=w[i:j]$</li><li>$z=w[j:]$</li></ol><h4 id=proving-languages-not-to-be-regular>Proving languages not to be Regular</h4><p>We do a game between 2 players as follows:</p><ol><li>Player 1 picks the language $L$ to be proved nonregular.</li><li>Player 2 picks $n$, but doesn&rsquo;t reveal to player 1 what $n$ is; player 1 must devise a play for all possible $n$&rsquo;s.</li><li>Player 1 picks $w$, which may depend on $n$ and which must be of length at least $n$ and $w\in L$.</li><li>Player 2 divides $w$ into $x$, $y$ and $z$, obeying the constraints that are stipulated in the pumping lemma; $y\ne\epsilon$ and $|xy|\le n$ and doesn&rsquo;t tell player 1 what $x$, $y$ and $z$.</li><li>Player 1 &ldquo;wins&rdquo; by picking $k$, which may be a function of $n$, $x$, $y$ and $z$, such that $xy^kz$ is not in $L$.</li></ol><p>Thus L must not be regular as it doesn&rsquo;t follow the pumping lemma.</p><h3 id=closure-properties>Closure Properties</h3><h4 id=closure-under-boolean-operations>Closure under Boolean Operations</h4><blockquote><p>$R_L =$ regular expression for language $L$</p></blockquote><ol><li><p>Closure under <em>union</em></p><h5 id=theorem-if-l-and-m-are-regular-then-lcup-m-is-also-regular><strong>Theorem</strong>: If $L$ and $M$ are regular then $L\cup M$ is also regular.</h5><p>Proof:
$L\cup M=L(R_L+R_M)$</p></li><li><p>Closure under <em>complementation</em></p><h5 id=theorem-if-l-is-regular-then-so-is-bar-l><strong>Theorem</strong>: If $L$ is regular then so is $\bar L$.</h5><p>Proof: Convert $R_L$ to DFA and take complement of it and construct the regular expression again to get $R_{\bar L}$</p></li><li><p>Closure under <em>Intersection</em></p><h5 id=theorem-if-l-and-m-are-regular-then-lcap-m-is-also-regular><strong>Theorem</strong>: If $L$ and $M$ are regular then $L\cap M$ is also regular.</h5><p>Proof: $L\cap M=\overline{\overline L\cup\overline M}$</p></li><li><p>Closure under <em>difference</em></p><h5 id=theorem-if-l-and-m-are-regular-then-l-m-is-also-regular><strong>Theorem</strong>: If $L$ and $M$ are regular then $L-M$ is also regular.</h5><p>Proof: $L-M=L\cap\overline M$</p></li></ol><h4 id=reversal>Reversal</h4><blockquote><p>$L^R$ is defined as the reversal of the language $L$.</p></blockquote><h5 id=theorem-if-l-is-regular-language-then-so-is-lr><strong>Theorem</strong>: If $L$ is regular language then so is $L^R$.</h5><p>Proof
Construct the DFA $A$ of $L$ and reverse all the edges of $A$ and make final states as start states and start states as end states.</p><h3 id=descision-properties>Descision Properties</h3><h4 id=converting-among-representations>Converting among Representations</h4><ul><li>NFA to DFA: $\mathcal O(n^32^n)$</li><li>DFA to NFA: $\mathcal O(n)$</li><li>DFA to RegEx: $\mathcal O(n^34^n)$</li><li>NFA to RegEx: $\mathcal O(n^34^{n^32^n})$</li><li>RegEx to $\epsilon$-NFA: $\mathcal O(n^3)$</li></ul><h4 id=testing-emptiness-of-regular-languages>Testing Emptiness of Regular Languages</h4><p>Given a DFA apply BFS to check if any final state is reachable from the start state.</p><p>For a Regular Expression,</p><ul><li><em>Basis</em>: $\empty$ is the empty language.</li><li><em>Induction</em>: Four cases must be considered:<ol><li>$R=R_1+R_2$ then $L(R)$ is empty iff both $L(R_1)$ and $L(R_2)$ are empty.</li><li>$R=R_1R_2$ then $L(R)$ is empty iff both $L(R_1)$ or $L(R_2)$ are empty.</li><li>$R=R_1^*$ then $L(R)$ is not empty.</li><li>$R=(R_1)$ then $L(R)$ is empty iff $L(R_1)$ is empty.</li></ol></li></ul><h4 id=testing-membership-in-a-regular-language>Testing Membership in a Regular Language</h4><p>For a string $w$ with $|w|=n$ and $s$ states,</p><ul><li>DFA: $\mathcal O(n)$</li><li>$\epsilon$-NFA: $\mathcal O(ns^2)$</li><li>RegEx: $\mathcal O(ns^2)$</li></ul><h3 id=equivalence-and-minimization-of-automata>Equivalence and Minimization of Automata</h3><h4 id=testing-equivalence-of-states>Testing Equivalence of States</h4><dl><dt>Equivalent States $(p,q)$</dt><dd>For all input strings $w$, $\hat\delta(p,w)$ is an accepting state iff $\hat\delta(q,w)$ is an accepting state.</dd></dl><p>Finding all pairs of distinguishable pairs by table method.</p><ul><li><em>Basis</em>: If $p$ is an accepting state and $q$ is a nonaccepting, then the pair $\{p,q\}$ is distinguishable.</li><li><em>Induction</em>: Let $r=\delta(p,a)$ and $s=\delta(q,a)$ then $p$ and $q$ are distinguishable if $r$ and $s$ are known to be distinguishable.</li></ul><h5 id=theorem-any-pair-that-is-left-indistinguishable-from-the-table-filling-algorithm-then-the-states-are-equivatent><strong>Theorem</strong>: Any pair that is left indistinguishable from the table-filling algorithm then the states are equivatent.</h5><h4 id=minimization-of-dfas>Minimization of DFA&rsquo;s</h4><h5 id=theorem-the-equivalence-states-are-transitive-that-is-if-in-some-dfa-aqsumdeltaq_0f-we-find-that-states-p-and-q-are-equivalent-and-we-also-find-that-q-and-r-are-equivalent-then-it-must-be-that-p-and-r-are-equivalent><strong>Theorem</strong>: The equivalence states are transitive. That is, if in some DFA $A=(Q,\sum,\delta,q_0,F)$ we find that states $p$ and $q$ are equivalent, and we also find that $q$ and $r$ are equivalent, then it must be that $p$ and $r$ are equivalent.</h5><p>Therefore the &ldquo;equivalence of states&rdquo; is an equivalence relation over $Q$. This means we can divide the $Q$ into different equivalence classes and the Minimal DFA needs to have at least these many states representing every equivalence class.</p></div></article></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/Scrolls/tags/computer-science/>Computer-Science</a></span>
<span><a href=/Scrolls/tags/machine-learning/>Machine-Learning</a></span>
<span><a href=/Scrolls/tags/programming-languages/>Programming-Languages</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#resources>Resources</a><ul><li><a href=#hopcrot-motwani-ullmanhttpswww-2dcubaarstaffbecherhopcroft-motwani-ullman-2001pdf><a href=https://www-2.dc.uba.ar/staff/becher/Hopcroft-Motwani-Ullman-2001.pdf>Hopcrot-Motwani-Ullman</a></a></li></ul></li><li><a href=#central-concepts>Central Concepts</a><ul><li><a href=#alphabets>Alphabets</a></li><li><a href=#strings>Strings</a></li><li><a href=#languages>Languages</a></li><li><a href=#problems>Problems</a></li></ul></li><li><a href=#finite-state-automaton>Finite State Automaton</a><ul><li><a href=#deterministic-finite-automaton>Deterministic Finite Automaton</a></li><li><a href=#nondeterministic-finite-automaton>Nondeterministic Finite Automaton</a></li><li><a href=#finite-automaton-with-epsilon-transition>Finite Automaton with $\epsilon$-transition</a></li></ul></li><li><a href=#regular-expressions-and-languages>Regular Expressions and Languages</a><ul><li><a href=#regular-expressions>Regular Expressions</a></li><li><a href=#finite-automata-and-regular-expressions>Finite Automata and Regular-Expressions</a></li><li><a href=#algebraic-laws-for-regular-expressions>Algebraic Laws for Regular Expressions</a></li></ul></li><li><a href=#properties-of-regular-languages>Properties of Regular Languages</a><ul><li><a href=#pumping-lemma>Pumping Lemma</a></li><li><a href=#closure-properties>Closure Properties</a></li><li><a href=#descision-properties>Descision Properties</a></li><li><a href=#equivalence-and-minimization-of-automata>Equivalence and Minimization of Automata</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/Scrolls/tags/computer-science/>Computer-Science</a></span>
<span><a href=/Scrolls/tags/machine-learning/>Machine-Learning</a></span>
<span><a href=/Scrolls/tags/programming-languages/>Programming-Languages</a></span></div></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2022
<a href=https://adityakadoo.github.io/Scrolls/></a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/Scrolls/assets/js/fuji.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script>
<script>renderMathInElement(document.querySelector("div.content"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>