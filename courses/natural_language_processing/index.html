<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="Aditya Kadoo"><meta name=description content="Part of Speech Tagging HMM-based Tagging Parameters Input: A sequence of words and labels Output: A sequence of labels for every word Penn tag-set is generally used for POS tagging in english language.
Hidden Markov Model There are 2 kinds of probabilities:
Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$. Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$."><link rel=icon href=https://adityakadoo.github.io/Scrolls/favicon.ico><meta name=keywords content=" hugo  latex  theme "><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script><meta property="og:title" content="Natural Language Processing"><meta property="og:description" content="Part of Speech Tagging HMM-based Tagging Parameters Input: A sequence of words and labels Output: A sequence of labels for every word Penn tag-set is generally used for POS tagging in english language.
Hidden Markov Model There are 2 kinds of probabilities:
Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$. Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$."><meta property="og:type" content="article"><meta property="og:url" content="https://adityakadoo.github.io/Scrolls/courses/natural_language_processing/"><meta property="article:section" content="courses"><meta property="article:published_time" content="2022-08-24T09:49:01+05:30"><meta property="article:modified_time" content="2022-08-24T09:49:01+05:30"><link rel=canonical href=https://adityakadoo.github.io/Scrolls/courses/natural_language_processing/><meta itemprop=name content="Natural Language Processing"><meta itemprop=description content="Part of Speech Tagging HMM-based Tagging Parameters Input: A sequence of words and labels Output: A sequence of labels for every word Penn tag-set is generally used for POS tagging in english language.
Hidden Markov Model There are 2 kinds of probabilities:
Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$. Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$."><meta itemprop=datePublished content="2022-08-24T09:49:01+05:30"><meta itemprop=dateModified content="2022-08-24T09:49:01+05:30"><meta itemprop=wordCount content="783"><meta itemprop=keywords content="Computer-Science,Machine-Learning,"><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/common.css><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/content.css><title>Natural Language Processing - Scrolls</title>
<meta name=twitter:card content="summary"><meta name=twitter:title content="Natural Language Processing"><meta name=twitter:description content="Part of Speech Tagging HMM-based Tagging Parameters Input: A sequence of words and labels Output: A sequence of labels for every word Penn tag-set is generally used for POS tagging in english language.
Hidden Markov Model There are 2 kinds of probabilities:
Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$. Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$."><link rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/single.css></head><body><div id=wrapper><header id=header><h1>Natural Language Processing</h1><nav><span class=nav-bar-item><a class=link href></a></span></nav><p></p></header><main id=main class=post><article class=content><div class=tableofcontent></div><h2 id=part-of-speech-tagging>Part of Speech Tagging</h2><h3 id=hmm-based-tagging>HMM-based Tagging</h3><h4 id=parameters>Parameters</h4><ul><li><em>Input</em>: A sequence of words and labels</li><li><em>Output</em>: A sequence of labels for every word</li></ul><blockquote><p>Penn tag-set is generally used for POS tagging in english language.</p></blockquote><h4 id=hidden-markov-model>Hidden Markov Model</h4><p>There are 2 kinds of probabilities:</p><ol><li>Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$.</li><li>Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$.</li></ol><blockquote><p>By Markov assumption, current word&rsquo;s tag only depends on previous word&rsquo;s tag.</p></blockquote><h4 id=viterbi-algorithm>Viterbi Algorithm</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#define BProb(t1,t0) () </span><span class=c1>// Bigram
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1></span><span class=cp>#define LProb(w,t) () </span><span class=c1>// Lexical
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>viterbi</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>sentence</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>labels</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>sentence</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=n>labels</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=c1>// labels[0] = &#34;^&#34;
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c1></span>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&gt;</span> <span class=n>plabel</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>l</span><span class=p>,</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>l</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>);</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>k</span><span class=o>&lt;</span><span class=n>l</span><span class=p>;</span><span class=n>k</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>                <span class=kt>float</span> <span class=n>p</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>                    <span class=o>*</span> <span class=n>BProb</span><span class=p>(</span><span class=n>labels</span><span class=p>[</span><span class=n>j</span><span class=p>],</span><span class=n>labels</span><span class=p>[</span><span class=n>k</span><span class=p>])</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>                    <span class=o>*</span> <span class=n>LProb</span><span class=p>(</span><span class=n>sentence</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>labels</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span><span class=n>p</span><span class=p>){</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>                    <span class=n>plabel</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>(</span><span class=n>sentence</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span><span class=n>sentence</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=kt>int</span> <span class=n>ptr</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>l</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>        <span class=n>ptr</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>ptr</span><span class=p>]</span><span class=o>&lt;</span><span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>?</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>    <span class=n>res</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>res</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=s>&#34;_.&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>        <span class=n>ptr</span> <span class=o>=</span> <span class=n>slabel</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>ptr</span><span class=p>];</span>
</span></span><span class=line><span class=ln>29</span><span class=cl>        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+=</span> <span class=s>&#34;_&#34;</span><span class=o>+</span><span class=n>labels</span><span class=p>[</span><span class=n>ptr</span><span class=p>];</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=ln>32</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=discriminative-learning>Discriminative Learning</h3><p>HMM based POS tagging cannot handle &ldquo;free word order&rdquo; and &ldquo;agglutination&rdquo; well.</p><h4 id=feature-engineering>Feature Engineering</h4><ol><li>Word-based features<ul><li>$f_{21}$: Dictionary index of the current word</li><li>$f_{22}$: Dictionary index of the previous word</li><li>$f_{23}$: Dictionary index of the next word</li></ul></li><li>Part of Speech tag-based features<ul><li>$f_{24}$: Index of POS of previous word</li></ul></li><li>Morphology-based features<ul><li>$f_{25}$: does the current word have a noun suffix like &rsquo;s&rsquo;, &rsquo;es&rsquo;, &lsquo;ies&rsquo;, etc.</li><li>$f_{26}$: does the current word have a verbal suffix like &rsquo;d&rsquo;, &rsquo;ed&rsquo;, &rsquo;t&rsquo;, etc.</li><li>$f_{27}$ and $f_{28}$: above two for previous word.</li><li>$f_{29}$ and $f_{2,10}$: above two for next word.</li></ul></li></ol><h4 id=morphology>Morphology</h4><dl><dt>Morphemes</dt><dd>Smallest meaning-bearing units forming a word.
e.g.: In &ldquo;quickly&rdquo;, &ldquo;quick&rdquo; and &ldquo;ly&rdquo;.</dd></dl><ul><li><strong>Analytic Languages</strong>: Morphemes largely separate from one another.</li><li><strong>Synthetic Languages</strong>: Joins the morphemes.</li></ul><dl><dt>Syncretism</dt><dd>Overloading of roles per morpheme is called <em><strong>syncretism</strong></em>.
e.g.: &ldquo;will go&rdquo;: since number and person are indeterminate here</dd></dl><h4 id=maximum-entropy-markov-model>Maximum Entropy Markov Model</h4><p>$$
P(t_i=t|F_i)=\dfrac{e^{\sum_{j=1.k}\lambda_jf_{ij}}}{{\sum_{t&rsquo;\in S}}e^{\sum_{j=1.k}\lambda_jf_{ij}(t&rsquo;)}}
$$</p><h4 id=beam-search-algorithm>Beam Search Algorithm</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#define Prob(t,w) ()
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>beam_search</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>sentence</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>labels</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>sentence</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=n>labels</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// Beam size
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=c1></span>    <span class=c1>// labels[0] = &#34;^&#34;
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c1></span>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;&gt;&gt;</span> <span class=n>best</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;&gt;</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>make_pair</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=p>))));</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=n>best</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>].</span><span class=n>first</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=n>best</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>].</span><span class=n>second</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=n>best</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>].</span><span class=n>first</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>        <span class=n>best</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>l</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>u</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>u</span><span class=o>&lt;</span><span class=n>l</span><span class=p>;</span><span class=n>u</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>                <span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=n>best</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>].</span><span class=n>first</span><span class=o>*</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>                    <span class=n>Prob</span><span class=p>(</span><span class=n>best</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>].</span><span class=n>second</span><span class=p>,</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>label</span><span class=p>[</span><span class=n>u</span><span class=p>]),</span><span class=n>best</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>].</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>                <span class=n>labls</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>                <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>v</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>v</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>                    <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>&gt;</span><span class=n>best</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>v</span><span class=p>])</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>                        <span class=n>swap</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=n>best</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>v</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>maxp</span> <span class=o>=</span> <span class=n>max_element</span><span class=p>(</span><span class=n>best</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>begin</span><span class=p>(),</span><span class=n>best</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>maxp</span><span class=p>.</span><span class=n>second</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>29</span><span class=cl>        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>labels</span><span class=p>[</span><span class=n>maxp</span><span class=p>.</span><span class=n>second</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=ln>31</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=parsing>Parsing</h2><h3 id=context-free-grammar-parsing>Context Free Grammar Parsing</h3><p>We are given a CFG with terminals as POS tags from the language and vairables from segment labels. This grammar is converted to Chomsky form.</p><h4 id=cyk-algorithm>CYK Algorithm</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=k>class</span> <span class=nc>node</span><span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=n>string</span> <span class=n>label</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=n>node</span><span class=o>*</span> <span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=n>node</span><span class=o>*</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=n>node</span><span class=o>*</span> <span class=nf>CYK</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;&gt;</span> <span class=n>sent</span><span class=p>,</span> <span class=n>map</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>rules</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>pos_labels</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;&gt;&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>            <span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>make_pair</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=s>&#34;&#34;</span><span class=p>)));</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span><span class=n>j</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>==</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>sent</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>            <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;---&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>                <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>=</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span><span class=n>k</span><span class=o>&lt;=</span><span class=n>i</span><span class=p>;</span><span class=n>k</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>                    <span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=n>second</span><span class=p>,</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>                                                         <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>                    <span class=k>if</span><span class=p>(</span><span class=n>rules</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>rule</span><span class=p>)</span><span class=o>!=</span><span class=n>rules</span><span class=p>.</span><span class=n>end</span><span class=p>()){</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>                        <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>rules</span><span class=p>[</span><span class=n>rule</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>                        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=n>node</span><span class=o>*</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>    <span class=c1>// make the tree
</span></span></span><span class=line><span class=ln>29</span><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=ln>30</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=shift-reduce-algorithm>Shift reduce algorithm</h4><p>Using a stack and working through a Push-down automaton based on the language.</p><h3 id=probabilistic-parsing>Probabilistic Parsing</h3><p>In the normal CFG related to the language, we add probability value to each rule. This can be found using the dataset.</p><p>Probability of a Parse Tree is defined as the product probabilities of all the rules used in the parse tree. This way we find the parse tree with highest probability.</p><p>We can also define the probability of a sentence as the sum of probabilities of its parse trees.
$$
P(S) = \sum_{t} P(t)\cdot P(S|t) = \sum_{t} P(t)
$$</p><h3 id=dependency-parsing>Dependency Parsing</h3><p>Instead of creating chunks of words we create dependency relations between words itself. This creates a tree of words as nodes.</p><h2 id=ffnnbp>FFNNBP</h2><p>Use softmax or sigmoid for sentiment analysis.</p><h2 id=wordnet>WordNet</h2><ul><li><em><strong>Syntagmatic</strong></em>: Based on relations such as Synonym, antonym, etc. <em>CAT</em> and <em>ANIMAL</em></li><li><em><strong>Paradigmatic</strong></em>: Based on Co-occurences. <em>CAT</em> and <em>MEW</em></li></ul><h3 id=wordnet-engineering>Wordnet Engineering</h3><dl><dt>Principles of Synset creation</dt><dd><ul><li>Minimality</li><li>Coverage</li><li>Replacibility</li></ul></dd></dl><p>These synsets are used to create Syntagmatic ConceptNets.</p><p>Calculate Lexical Semantic Association(LSA) i.e. matrix of co-occurence frequencies. Apply PCA to get Paradigmatic WordNets.</p><h3 id=using-wordnets>Using WordNets</h3><p>$$P(Context\ word | input\ word)=P(w_1|w_2)=\frac{e^{(u_{w_1}^Tu_{w_2})}}{\Sigma_k e^{(u_{w_1}^Tu_{w_k})}}$$</p><blockquote><p>Here $u_w$ is the word vector for $w$.</p></blockquote></article></main><footer id=footer><div><span>© 2022</span> - <span>2023</span></div><div><span>Powered by </span><a class=link href=https://gohugo.io/>Hugo</a>
<span>🍦 Theme </span><a class=link href=https://github.com/queensferryme/hugo-theme-texify>TeXify</a></div><div class=footnote><span>Follow me on <a class=link href=https://github.com/adityakadoo>GitHub</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></span></div></footer></div><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/syntax.css></body></html>