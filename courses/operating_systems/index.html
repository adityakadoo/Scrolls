<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=author content="Aditya Kadoo"><meta name=description content="Resources Operating Systems - Three Easy Pieces Introduction to OS Main objectives of OS include:-
CPU Virtualization : Making using the processor easy. Memory Virtualization : Making storage in memory easy. Concurrency : Ensuring correctness when multiple programs run together. Persistence : Ensuring permanent memory does not get erased and stays organised. Design Goals : Abstractions, performance, isolation, reliability, energy-efficiency CPU Virtualization Abstraction : Process The abstraction provided by the OS of a running program is called a process."><link rel=icon href=https://adityakadoo.github.io/Scrolls/favicon.ico><meta name=keywords content=" hugo  latex  theme "><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script><meta property="og:title" content="Operating Systems"><meta property="og:description" content="Resources Operating Systems - Three Easy Pieces Introduction to OS Main objectives of OS include:-
CPU Virtualization : Making using the processor easy. Memory Virtualization : Making storage in memory easy. Concurrency : Ensuring correctness when multiple programs run together. Persistence : Ensuring permanent memory does not get erased and stays organised. Design Goals : Abstractions, performance, isolation, reliability, energy-efficiency CPU Virtualization Abstraction : Process The abstraction provided by the OS of a running program is called a process."><meta property="og:type" content="article"><meta property="og:url" content="https://adityakadoo.github.io/Scrolls/courses/operating_systems/"><meta property="article:section" content="courses"><meta property="article:published_time" content="2022-08-19T10:31:05+05:30"><meta property="article:modified_time" content="2022-08-19T10:31:05+05:30"><link rel=canonical href=https://adityakadoo.github.io/Scrolls/courses/operating_systems/><meta itemprop=name content="Operating Systems"><meta itemprop=description content="Resources Operating Systems - Three Easy Pieces Introduction to OS Main objectives of OS include:-
CPU Virtualization : Making using the processor easy. Memory Virtualization : Making storage in memory easy. Concurrency : Ensuring correctness when multiple programs run together. Persistence : Ensuring permanent memory does not get erased and stays organised. Design Goals : Abstractions, performance, isolation, reliability, energy-efficiency CPU Virtualization Abstraction : Process The abstraction provided by the OS of a running program is called a process."><meta itemprop=datePublished content="2022-08-19T10:31:05+05:30"><meta itemprop=dateModified content="2022-08-19T10:31:05+05:30"><meta itemprop=wordCount content="2602"><meta itemprop=keywords content="Computer-Science,"><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/common.css><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/content.css><title>Operating Systems - Scrolls</title><meta name=twitter:card content="summary"><meta name=twitter:title content="Operating Systems"><meta name=twitter:description content="Resources Operating Systems - Three Easy Pieces Introduction to OS Main objectives of OS include:-
CPU Virtualization : Making using the processor easy. Memory Virtualization : Making storage in memory easy. Concurrency : Ensuring correctness when multiple programs run together. Persistence : Ensuring permanent memory does not get erased and stays organised. Design Goals : Abstractions, performance, isolation, reliability, energy-efficiency CPU Virtualization Abstraction : Process The abstraction provided by the OS of a running program is called a process."><link rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/single.css></head><body><div id=wrapper><header id=header><h1><a href=https://adityakadoo.github.io/Scrolls/>Operating Systems</a></h1><nav><span class=nav-bar-item><a class=link href></a></span></nav></header><main id=main class=post><article class=content><h2>Contents</h2><div class=tableofcontent><nav id=TableOfContents><ol><li><a href=#resources>Resources</a><ol><li><a href=#operating-systems---three-easy-pieceshttpstechiefood4ufileswordpresscom202002operating_systems_three_easy_piecespdf><a href=https://techiefood4u.files.wordpress.com/2020/02/operating_systems_three_easy_pieces.pdf>Operating Systems - Three Easy Pieces</a></a></li></ol></li><li><a href=#introduction-to-os>Introduction to OS</a></li><li><a href=#cpu-virtualization>CPU Virtualization</a><ol><li><a href=#abstraction--process>Abstraction : Process</a><ol><li><a href=#process-api>Process API</a></li><li><a href=#process-creation>Process Creation</a></li><li><a href=#process-states>Process States</a></li><li><a href=#data-structures>Data Structures</a></li><li><a href=#process-api-in-linux>Process API in Linux</a></li><li><a href=#fork-system-call><code>fork()</code> system call</a></li><li><a href=#adding-wait-system-call>Adding <code>wait()</code> system call</a></li><li><a href=#finally-the-exec-system-call>Finally, the <code>exec()</code> system call</a></li></ol></li><li><a href=#limited-direct-execution>Limited Direct Execution</a><ol><li><a href=#problem-1-restricted-operations>Problem #1: Restricted Operations</a></li><li><a href=#switching-between-process>Switching Between Process</a></li><li><a href=#saving-and-restoring-context>Saving and Restoring Context</a></li></ol></li><li><a href=#scheduling>Scheduling</a><ol><li><a href=#workload-assumptions>Workload Assumptions</a></li><li><a href=#scheduling-metrics>Scheduling Metrics</a></li><li><a href=#first-in-first-out>First In First Out</a></li><li><a href=#shortest-job-first>Shortest Job First</a></li><li><a href=#shortest-time-to-completion-first>Shortest Time-to-Completion First</a></li><li><a href=#round-robin>Round Robin</a></li><li><a href=#incorporating-io>Incorporating I/O</a></li><li><a href=#multi-level-feedback-queues>Multi-Level Feedback Queues</a></li></ol></li></ol></li><li><a href=#memory-virtualization>Memory Virtualization</a><ol><li><a href=#abstraction--address-spaces>Abstraction : Address Spaces</a><ol><li><a href=#memory-api>Memory API</a></li><li><a href=#automaticstack-memory>Automatic/Stack Memory</a></li><li><a href=#heap-memory>Heap Memory</a></li><li><a href=#address-translation>Address Translation</a></li><li><a href=#segmentation>Segmentation</a></li><li><a href=#free-space-management>Free Space Management</a></li></ol></li><li><a href=#paging>Paging</a><ol><li><a href=#address-translation-1>Address Translation</a></li><li><a href=#page-table-entry>Page Table entry</a></li><li><a href=#problems-with-paging>Problems with Paging</a></li><li><a href=#faster-translations>Faster Translations</a></li><li><a href=#smaller-tables>Smaller Tables</a></li></ol></li></ol></li><li><a href=#concurrency>Concurrency</a><ol><li><a href=#abstraction--threads-locks-and-cvs>Abstraction : Threads, Locks and CVs</a><ol><li><a href=#ways-to-create-locks>Ways to create Locks</a></li></ol></li></ol></li><li><a href=#persistence>Persistence</a><ol><li><a href=#abstraction--file-systems>Abstraction : File Systems</a></li></ol></li></ol></nav></div><h2 id=resources>Resources</h2><ul><li><h3 id=operating-systems---three-easy-pieceshttpstechiefood4ufileswordpresscom202002operating_systems_three_easy_piecespdf><a href=https://techiefood4u.files.wordpress.com/2020/02/operating_systems_three_easy_pieces.pdf>Operating Systems - Three Easy Pieces</a></h3></li></ul><h2 id=introduction-to-os>Introduction to OS</h2><p>Main objectives of OS include:-</p><ol><li><strong>CPU Virtualization</strong> : Making using the processor easy.</li><li><strong>Memory Virtualization</strong> : Making storage in memory easy.</li><li><strong>Concurrency</strong> : Ensuring correctness when multiple programs run together.</li><li><strong>Persistence</strong> : Ensuring permanent memory does not get erased and stays organised.</li><li><strong>Design Goals</strong> : Abstractions, performance, isolation, reliability, energy-efficiency</li></ol><h2 id=cpu-virtualization>CPU Virtualization</h2><h3 id=abstraction--process>Abstraction : Process</h3><p>The abstraction provided by the OS of a running program is called a <em><strong>process</strong></em>.</p><p>The OS creates the illusion of <strong>virtualization</strong> the CPU by running one process, then stopping it and running another, and so forth. This is known as <strong>time sharing</strong> of the CPU.</p><blockquote><p><strong>Time sharing</strong> is one of the most basic techniques used by an OS to share a resource. By allowing the resource to be used for a little while by one entity, and then a little while by another, and so forth. The natural counterpart of time sharing is <strong>space sharing</strong>, where a resource is divided (in space) among those who wish to use it.</p></blockquote><h4 id=process-api>Process API</h4><ul><li><strong>Create</strong>: Spawns a new process.</li><li><strong>Destroy</strong>: Kills a process forcefully.</li><li><strong>Wait</strong>: Wait for a process to finish.</li><li><strong>Status</strong>: Every process has a state associated with it.</li><li><strong>Miscellaneous Control</strong>: Halt, resume, etc.</li></ul><h4 id=process-creation>Process Creation</h4><ol><li>Loading the <em>code</em> into executable format.</li><li>Initializing the process&rsquo;s runtime <em>stack</em>.</li><li>Initializing the program&rsquo;s <em>heap</em> memory.</li><li>Setup <em>file descriptors</em> associated with <em>input</em>, <em>output</em> and <em>error</em> streams.</li></ol><h4 id=process-states>Process States</h4><p>Following are the types of states a process can be in:-</p><ul><li><strong>Running</strong></li><li><strong>Ready</strong></li><li><strong>Blocked</strong></li></ul><div class="goat svg-container"><svg xmlns="http://www.w3.org/2000/svg" font-family="Menlo,Lucida Console,monospace" viewBox="0 0 272 169"><g transform="translate(8,16)"><path d="M16 0H64" fill="none" stroke="currentcolor"/><path d="M208 0h32" fill="none" stroke="currentcolor"/><path d="M88 16h96" fill="none" stroke="currentcolor"/><path d="M88 32h96" fill="none" stroke="currentcolor"/><path d="M16 48H64" fill="none" stroke="currentcolor"/><path d="M208 48h32" fill="none" stroke="currentcolor"/><path d="M112 96h48" fill="none" stroke="currentcolor"/><path d="M72 112H88" fill="none" stroke="currentcolor"/><path d="M184 112h16" fill="none" stroke="currentcolor"/><path d="M112 144h48" fill="none" stroke="currentcolor"/><path d="M0 16V32" fill="none" stroke="currentcolor"/><path d="M80 16V32" fill="none" stroke="currentcolor"/><path d="M96 112v16" fill="none" stroke="currentcolor"/><path d="M176 112v16" fill="none" stroke="currentcolor"/><path d="M192 16V32" fill="none" stroke="currentcolor"/><path d="M256 16V32" fill="none" stroke="currentcolor"/><path d="M2e2 112l24-48" fill="none" stroke="currentcolor"/><path d="M48 64l24 48" fill="none" stroke="currentcolor"/><polygon points="96.000000,32.000000 84.000000,26.400000 84.000000,37.599998" fill="currentcolor" transform="rotate(180.000000, 88.000000, 32.000000)"/><polygon points="96.000000,112.000000 84.000000,106.400002 84.000000,117.599998" fill="currentcolor" transform="rotate(0.000000, 88.000000, 112.000000)"/><polygon points="192.000000,16.000000 180.000000,10.400000 180.000000,21.600000" fill="currentcolor" transform="rotate(0.000000, 184.000000, 16.000000)"/><polygon points="192.000000,112.000000 180.000000,106.400002 180.000000,117.599998" fill="currentcolor" transform="rotate(180.000000, 184.000000, 112.000000)"/><path d="M16 0A16 16 0 000 16" fill="none" stroke="currentcolor"/><path d="M64 0A16 16 0 0180 16" fill="none" stroke="currentcolor"/><path d="M208 0A16 16 0 00192 16" fill="none" stroke="currentcolor"/><path d="M240 0a16 16 0 0116 16" fill="none" stroke="currentcolor"/><path d="M0 32A16 16 0 0016 48" fill="none" stroke="currentcolor"/><path d="M80 32A16 16 0 0164 48" fill="none" stroke="currentcolor"/><path d="M192 32a16 16 0 0016 16" fill="none" stroke="currentcolor"/><path d="M256 32A16 16 0 01240 48" fill="none" stroke="currentcolor"/><path d="M112 96A16 16 0 0096 112" fill="none" stroke="currentcolor"/><path d="M160 96a16 16 0 0116 16" fill="none" stroke="currentcolor"/><path d="M96 128a16 16 0 0016 16" fill="none" stroke="currentcolor"/><path d="M176 128a16 16 0 01-16 16" fill="none" stroke="currentcolor"/><text text-anchor="middle" x="16" y="20" fill="currentcolor" style="font-size:1em">R</text><text text-anchor="middle" x="16" y="84" fill="currentcolor" style="font-size:1em">I</text><text text-anchor="middle" x="16" y="100" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="24" y="20" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="24" y="36" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="24" y="84" fill="currentcolor" style="font-size:1em">/</text><text text-anchor="middle" x="24" y="100" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="32" y="20" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="32" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="32" y="84" fill="currentcolor" style="font-size:1em">O</text><text text-anchor="middle" x="32" y="100" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="40" y="20" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="40" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="40" y="84" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="40" y="100" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="48" y="20" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="48" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="48" y="100" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="56" y="20" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="56" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="64" y="20" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">D</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="104" y="52" fill="currentcolor" style="font-size:1em">S</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="112" y="52" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="112" y="116" fill="currentcolor" style="font-size:1em">B</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="120" y="52" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="120" y="116" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="120" y="132" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="128" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="128" y="116" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="128" y="132" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="136" y="52" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="136" y="116" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="136" y="132" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="144" y="52" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="144" y="116" fill="currentcolor" style="font-size:1em">k</text><text text-anchor="middle" x="144" y="132" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="152" y="52" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="152" y="116" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="152" y="132" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="160" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="160" y="116" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="168" y="52" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="208" y="20" fill="currentcolor" style="font-size:1em">R</text><text text-anchor="middle" x="208" y="36" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="216" y="20" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="216" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="224" y="20" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="224" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="232" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="232" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="232" y="84" fill="currentcolor" style="font-size:1em">I</text><text text-anchor="middle" x="232" y="100" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="240" y="20" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="240" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="240" y="84" fill="currentcolor" style="font-size:1em">/</text><text text-anchor="middle" x="240" y="100" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="248" y="84" fill="currentcolor" style="font-size:1em">O</text><text text-anchor="middle" x="248" y="100" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="256" y="84" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="256" y="100" fill="currentcolor" style="font-size:1em">e</text></g></svg></div><h4 id=data-structures>Data Structures</h4><ul><li><strong>Process List</strong>: A list maintained by the OS of all the processes and their PCB.</li><li><strong>Process Control Block</strong> (PCB): A C struct that keeps track of all the meta-data associated with one process.</li></ul><h4 id=process-api-in-linux>Process API in Linux</h4><p>In UNIX systems new processes are created with the use of 2 system calls <code>fork()</code> and <code>exec()</code>.</p><h4 id=fork-system-call><code>fork()</code> system call</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello world.&#34;</span>,<span style=color:#00a000>getpid</span>());
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>int</span> rc <span style=color:#666>=</span> <span style=color:#00a000>fork</span>();
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (rc<span style=color:#666>&lt;</span><span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// fork failed
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>fprintf</span>(stderr, <span style=color:#b44>&#34;fork failed</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (rc <span style=color:#666>==</span> <span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// only executed by child
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello, I am child.</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>,<span style=color:#00a000>getpid</span>());
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// only executed by parent
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello, I am parent of %d.</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, <span style=color:#00a000>getpid</span>(), rc);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=adding-wait-system-call>Adding <code>wait()</code> system call</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello world.&#34;</span>,<span style=color:#00a000>getpid</span>());
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>int</span> rc <span style=color:#666>=</span> <span style=color:#00a000>fork</span>();
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (rc<span style=color:#666>&lt;</span><span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// fork failed
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>fprintf</span>(stderr, <span style=color:#b44>&#34;fork failed</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (rc <span style=color:#666>==</span> <span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// only executed by child
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello, I am child.</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>,<span style=color:#00a000>getpid</span>());
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// only executed by parent
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>// after waiting for child
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>while</span>(<span style=color:#00a000>wait</span>(<span style=color:#a2f>NULL</span>)<span style=color:#666>&gt;</span><span style=color:#666>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello, I am parent of %d.</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, <span style=color:#00a000>getpid</span>(), rc);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=finally-the-exec-system-call>Finally, the <code>exec()</code> system call</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello world.&#34;</span>,<span style=color:#00a000>getpid</span>());
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>int</span> rc <span style=color:#666>=</span> <span style=color:#00a000>fork</span>();
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (rc<span style=color:#666>&lt;</span><span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// fork failed
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>fprintf</span>(stderr, <span style=color:#b44>&#34;fork failed</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (rc <span style=color:#666>==</span> <span style=color:#666>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// only executed by child
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello, I am child.</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>,<span style=color:#00a000>getpid</span>());
</span></span><span style=display:flex><span>        <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>*</span>myargs[<span style=color:#666>3</span>];
</span></span><span style=display:flex><span>        myargs[<span style=color:#666>0</span>] <span style=color:#666>=</span> <span style=color:#00a000>strdup</span>(<span style=color:#b44>&#34;wc&#34;</span>);
</span></span><span style=display:flex><span>        myargs[<span style=color:#666>1</span>] <span style=color:#666>=</span> <span style=color:#00a000>strdup</span>(<span style=color:#b44>&#34;p3.c&#34;</span>);
</span></span><span style=display:flex><span>        myargs[<span style=color:#666>2</span>] <span style=color:#666>=</span> <span style=color:#a2f>NULL</span>;
</span></span><span style=display:flex><span>        <span style=color:#00a000>execvp</span>(myargs[<span style=color:#666>0</span>], myargs);
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// Child converted to a different program now
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;somethings wrong; I can feel it</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// only executed by parent
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>// after waiting for child
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>while</span>(<span style=color:#00a000>wait</span>(<span style=color:#a2f>NULL</span>)<span style=color:#666>&gt;</span><span style=color:#666>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#00a000>printf</span>(<span style=color:#b44>&#34;%d:hello, I am parent of %d.</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, <span style=color:#00a000>getpid</span>(), rc);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=limited-direct-execution>Limited Direct Execution</h3><p>Direct Execution can be explained by the following table,</p><table><thead><tr><th>OS</th><th>Program</th></tr></thead><tbody><tr><td>Create entry for process list</td><td></td></tr><tr><td>Allocate memory to program</td><td></td></tr><tr><td>Load program into memory</td><td></td></tr><tr><td>Set up stack with argc/argv</td><td></td></tr><tr><td>Clear registers</td><td></td></tr><tr><td>Execute call <code>main()</code></td><td></td></tr><tr><td></td><td>Run <code>main()</code></td></tr><tr><td></td><td>Execute return from <code>main()</code></td></tr><tr><td>Free memory of process</td><td></td></tr><tr><td>Remove from process list</td><td></td></tr></tbody></table><h4 id=problem-1-restricted-operations>Problem #1: Restricted Operations</h4><blockquote><p>How to perform restricted operations such as I/O or networking without giveing complete control over the system?</p></blockquote><p>We add processor modes:-</p><ul><li><em><strong>User mode</strong></em>: The code that runs here is restricted and can&rsquo;t issue I/O requests and it will kill the process.</li><li><em><strong>Kernel mode</strong></em>: In this mode the operating system runs the code and can do whatever it likes.</li></ul><blockquote><p>What should a user program do to perform some kind of privileged operation?</p></blockquote><p>The answer is <em><strong>system calls</strong></em>.</p><p>Every system call runs a special <code>trap</code> instruction which jumps the execution to kernel mode to do any privileged operation. Once finished the program can return to user mode by executing <code>return-from-trap</code> instruction.</p><p>While executing <code>trap</code>, the hardware needs to ensure the register state of the user program is stored and must be restored when <code>return-from-trap</code> is executed.</p><blockquote><p>How does the trap know which code to run inside the OS?</p></blockquote><p>The kernel sets-up a <strong>trap table</strong> at boot time in priviledged mode. OS informs the hardware of the locations of the <strong>trap handlers</strong>. Using this, whenever a hardware interrupt is
passed this code is run by the hardware from the trap handlers.
All these operation are also <strong>priviledge</strong> operations.</p><table><thead><tr><th>OS</th><th>Hardware</th><th>Program</th></tr></thead><tbody><tr><td>Initialize trap table</td><td>Remember addresses of syscall handler</td><td></td></tr><tr><td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</td><td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</td><td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</td></tr><tr><td>Create entry for process list</td><td></td><td></td></tr><tr><td>Allocate memory to program</td><td></td><td></td></tr><tr><td>Load program into memory</td><td></td><td></td></tr><tr><td>Set up stack with argc/argv</td><td></td><td></td></tr><tr><td>Clear registers</td><td></td><td></td></tr><tr><td><code>return-from-trap</code></td><td></td><td></td></tr><tr><td></td><td>restores regs to kernel stack</td><td></td></tr><tr><td></td><td>move to user mode</td><td></td></tr><tr><td></td><td>jump to <code>main()</code></td><td></td></tr><tr><td></td><td></td><td>Run <code>main()</code></td></tr><tr><td></td><td></td><td>Call syscall</td></tr><tr><td></td><td></td><td><code>trap</code> into OS</td></tr><tr><td></td><td>save regs to kernel stack</td><td></td></tr><tr><td></td><td>move to kernel mode</td><td></td></tr><tr><td></td><td>jump to trap handler</td><td></td></tr><tr><td>Handle trap</td><td></td><td></td></tr><tr><td>Execute system call</td><td></td><td></td></tr><tr><td><code>return-from-trap</code></td><td></td><td></td></tr><tr><td></td><td>restore regs from kernel stack</td><td></td></tr><tr><td></td><td>move to kernel mode</td><td></td></tr><tr><td></td><td>jump to PC after trap</td><td></td></tr><tr><td></td><td></td><td>return from main</td></tr><tr><td></td><td></td><td><code>trap</code> via <code>exit()</code></td></tr><tr><td>Free memory of process</td><td></td><td></td></tr><tr><td>Remove from process list</td><td></td><td></td></tr></tbody></table><h4 id=switching-between-process>Switching Between Process</h4><blockquote><p>How can the operating system <strong>regain control</strong> of the CPU so that it can switch process?</p></blockquote><ul><li><em><strong>Wait for system calls</strong></em>: When ever the user program makes system call or makes an error it returns the control back to the OS. Otherwise it can also make a <code>yield</code> call to return the control to the OS periodically.</li><li><em><strong>OS takes controls</strong></em>: This can be done using a simple <code>timer interrupt</code> that is raised after a fixed amount milliseconds.</li></ul><h4 id=saving-and-restoring-context>Saving and Restoring Context</h4><blockquote><p>Once the OS gains control, how to decide which process gets executed next?</p></blockquote><p>This is done by the <strong>scheduler</strong>. Once the decision is made the OS executes a low-level piece of code which is called <strong>context switch</strong>. It is basically saving the register values of the current process and restoring the same for the next process.</p><h3 id=scheduling>Scheduling</h3><h4 id=workload-assumptions>Workload Assumptions</h4><ol><li>Each job runs for the same amount of time.</li><li>All jobs arrive at the same time.</li><li>All jobs only use the CPU.</li><li>The run-time of each job is known.</li></ol><h4 id=scheduling-metrics>Scheduling Metrics</h4><p>We first define a performance index,
$$
T_{turnaround} = T_{completion} - T_{arrival}
$$
For now, $T_{turnaround} = T_{completion}$.</p><p>Another metric that we need to keep track of is fairness.</p><blockquote><p>Jain&rsquo;s Fairness Index?</p></blockquote><h4 id=first-in-first-out>First In First Out</h4><p>This works and produces least turnaround time with current assumptions.</p><p>I assumption 1 is removed, then this stops giving the most optimum solution.</p><h4 id=shortest-job-first>Shortest Job First</h4><p>This produces the best results without assumption 1.</p><p>If assumption 2 is also removed then in some cases this method performs poorly.</p><h4 id=shortest-time-to-completion-first>Shortest Time-to-Completion First</h4><p>With only assumptions 3 and 4 this is the theoretically most optimum solution. This can be easily implemented using a heap. It also makes use of timed interrupts and context switching.</p><p>In modern systems another new metric is quite important called <strong>Response time</strong>.
$$
T_{response} = T_{firstrun}-T_{arrival}
$$
STCF doesn&rsquo;t necessarily perform well in this case.</p><h4 id=round-robin>Round Robin</h4><p>Aka <strong>time slicing</strong>, in this method a time slice is fixed and after every such time period an interrupt is passed. After an interrupt the OS makes sure to rotate between different processes to ensure low response time and fairness.</p><h4 id=incorporating-io>Incorporating I/O</h4><p>This relaxes the 3rd assumption and whenever a process is engaged in I/O operation it is <em>blocked</em>. At it&rsquo;s place a different process is allowed to use the CPU.</p><h4 id=multi-level-feedback-queues>Multi-Level Feedback Queues</h4><ol><li>If Priority(A) > Priority(B), A runs (B doesn’t).</li><li>If Priority(A) = Priority(B), A & B run in RR.</li><li>When a job enters the system, it is placed at the highest
priority (the topmost queue).</li><li>Once a job uses up its time allotment at a given level (regardless of how many times it has given up the CPU), its priority is
reduced (i.e., it moves down one queue).</li><li>After some time period S, move all the jobs in the system
to the topmost queue.</li></ol><h2 id=memory-virtualization>Memory Virtualization</h2><h3 id=abstraction--address-spaces>Abstraction : Address Spaces</h3><p><img src=images/address_space.png alt="Address space example"></p><p>3 regions of code in the address space:-</p><ul><li>Code: Keeps the data related to the code</li><li>Stack: Keeps track of the function calls and scope variables</li><li>Heap: Holds the dynamically allocated memory</li></ul><p>Objectives of Memory virtualization:-</p><ul><li>Transparency</li><li>Efficiency</li><li>Protection/Isolation</li></ul><h4 id=memory-api>Memory API</h4><h4 id=automaticstack-memory>Automatic/Stack Memory</h4><p>This is the memory that is accessed when using a variable on <strong>stack</strong>. This is temporary and is overwritten when the variable goes out of scope</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>int</span> x; <span style=color:#080;font-style:italic>// declares an integer on the stack
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=heap-memory>Heap Memory</h4><p>This is a long-lived memory which is handled explicitly by the programmer.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>int</span> <span style=color:#666>*</span>x <span style=color:#666>=</span> (<span style=color:#0b0;font-weight:700>int</span> <span style=color:#666>*</span>) <span style=color:#00a000>malloc</span>(<span style=color:#a2f;font-weight:700>sizeof</span>(<span style=color:#0b0;font-weight:700>int</span>)); <span style=color:#080;font-style:italic>// allocates memory on heap
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    ...
</span></span><span style=display:flex><span>    <span style=color:#00a000>free</span>(x); <span style=color:#080;font-style:italic>// frees the allocated memory
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>}
</span></span></code></pre></div><blockquote><p><code>malloc()</code> and <code>free()</code> are not system calls but library calls built on top of system calls. Apart from these there is <code>calloc()</code> and <code>realloc()</code>.</p></blockquote><blockquote><p><code>mmap()</code> is another call to get <strong>anonymous</strong> memory allocated in the swap space.</p></blockquote><h4 id=address-translation>Address Translation</h4><p>The hardware provides a generic technique called <strong>hardware-based address translation</strong> to map virtual addresses to physical address but this is quite low-level and the OS has to step-in and manage which areas are free.</p><p>We assume that:</p><ul><li>Address space must be mapped to <em>contiguous</em> physical memory</li><li>The physical space is large compared to the address space</li><li>All address spaces are of exactly same size</li></ul><p>This is done at runtime by the <strong>Memory Management Unit(MMU)</strong> in the CPU. The hardware maintains a <strong>base</strong> and a <strong>bound</strong> to keep track of where an address space is mapped. If memory outside this is accessed CPU raises a segmentation fault.</p><p>OS thus has to maintain the location of memory not in use in a data structure such as <strong>free list</strong>.</p><h4 id=segmentation>Segmentation</h4><p>Instead of keeping track of base and bound pair of the entire address space as this wastes a lot of used space, store base and bound of different segments such as the code, stack and heap. Along with their seperate bounds also keep track of direction in which it grows and it&rsquo;s read/write permissions.</p><h5 id=os-issues>OS issues</h5><ol><li><em><strong>Context Switch</strong></em>: During a context switch the OS needs to make sure the addresses corresponding to all the segments of the address space are stored.</li><li><em><strong>External Fragmentation</strong></em>: This happens when the spaces left in between allocated segments is not enough to store a new segment but the total free space is sufficient to do so.</li></ol><h4 id=free-space-management>Free Space Management</h4><dl><dt>Free List Approach</dt><dd>Using a linked list to keep track of free unallocated segments of memory. Every node stores the start and size of the free segment. When new segements are to be allocated find a node with enough space and shrink it to account for newly occupied memory. Later when a segment is freed, collase joined node together.</dd></dl><p>Some allocation strategies</p><ul><li>Best fit: node with min size greater than required.</li><li>Worst fit: node with max size greater than required. Basically largest node.</li><li>First fit: first node greater than required. Greedy but fast.</li><li>Next fit: Instead of searching from the start search from the next node of last allocation.</li></ul><p>Other Approaches</p><ul><li>Segregated Allocator: Keeps a region of memory to allocate the most segments with the most frequent size and a separate block to keep segments with other sizes.</li><li>Buddy Allocator: Only divides free segments in half. Simplifies the coallesing part.</li></ul><h3 id=paging>Paging</h3><p>Memory is divided in terms of <em><strong>pages</strong></em> with fixed sizes. Thus every address space is given a fixed amount of pages.</p><h4 id=address-translation-1>Address Translation</h4><p>Every address can be broken into 2 parts: Virtual page number and the byte offset.</p><blockquote><p>For example, for a 64-byte address space i.e. 6-bit addresses and 16 byte page-size we get the 2-bit VPN and 4-bit offset.</p></blockquote><p>For a typical 32-bit address space with 4KB pages, the address is split into 20-bit VPN and 12-bit offset. This means $2^{20}$ VPN to PPN translation that the <strong>Page Table</strong> will have to hold. This means for 4 bytes per <strong>Page table entry</strong> a huge 4MB per process (400MB for 100 such processes). Thus the PgTable is stored in the memory somewhere.</p><h4 id=page-table-entry>Page Table entry</h4><ul><li><strong>Valid bit</strong>: Valid VPN or not.</li><li><strong>Protection bits</strong>: R/W permissions</li><li><strong>Present bit</strong>: Whether present in memory or not.</li><li><strong>Dirty bit</strong>: The page has been modified or not.</li><li><strong>Reference bit</strong>: Tracks whether a page has been accessed.</li></ul><h4 id=problems-with-paging>Problems with Paging</h4><ol><li>Too slow: The page table is stored in memory so for each memory access, 2 memory accesses are needed.</li><li>Too large: The total size of the Page Table is so large it needs to be stored in the memory.</li></ol><h4 id=faster-translations>Faster Translations</h4><dl><dt>Translation-Lookaside Buffer $(TLB)$</dt><dd>Its part of the MMU and simply caches the most popular virtual-to-physical address translations to improve performance. It works as follows</dd></dl><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>VPN <span style=color:#666>=</span> (VirtualAddress <span style=color:#666>&amp;</span> VPN_MASK) <span style=color:#666>&gt;&gt;</span> <span style=color:#00a000>SHIFT</span>
</span></span><span style=display:flex><span>(Success, TlbEntry) <span style=color:#666>=</span> <span style=color:#00a000>TLB_Lookup</span>(VPN)
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span> (Success <span style=color:#666>==</span> True) <span style=color:#080;font-style:italic>// TLB Hit
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>CanAccess</span>(TlbEntry.ProtectBits) <span style=color:#666>==</span> True)
</span></span><span style=display:flex><span>        Offset <span style=color:#666>=</span> VirtualAddress <span style=color:#666>&amp;</span> OFFSET_MASK
</span></span><span style=display:flex><span>        PhysAddr <span style=color:#666>=</span> (TlbEntry.PFN <span style=color:#666>&lt;&lt;</span> SHIFT) <span style=color:#666>|</span> Offset
</span></span><span style=display:flex><span>        <span style=color:#00a000>AccessMemory</span>(PhysAddr)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>else</span>
</span></span><span style=display:flex><span>        <span style=color:#00a000>RaiseException</span>(PROTECTION_FAULT)
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>else</span> <span style=color:#080;font-style:italic>// TLB Miss
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    PTEAddr <span style=color:#666>=</span> PTBR <span style=color:#666>+</span> (VPN <span style=color:#666>*</span> <span style=color:#a2f;font-weight:700>sizeof</span>(PTE))
</span></span><span style=display:flex><span>    PTE <span style=color:#666>=</span> <span style=color:#00a000>AccessMemory</span>(PTEAddr)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> (PTE.Valid <span style=color:#666>==</span> False)
</span></span><span style=display:flex><span>        <span style=color:#00a000>RaiseException</span>(SEGMENTATION_FAULT)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#00a000>CanAccess</span>(PTE.ProtectBits) <span style=color:#666>==</span> False)
</span></span><span style=display:flex><span>        <span style=color:#00a000>RaiseException</span>(PROTECTION_FAULT)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>else</span>
</span></span><span style=display:flex><span>        <span style=color:#00a000>TLB_Insert</span>(VPN, PTE.PFN, PTE.ProtectBits)
</span></span><span style=display:flex><span>        <span style=color:#00a000>RetryInstruction</span>()
</span></span></code></pre></div><p>TLB hits are typically handled by the hardware. When TLB misses are when the process traps into the OS and it is fetched this way.</p><p>To make sure a process has access to TLB entries relavent to it only, the TLB entries also carry a address space identifier unique to every process.</p><table><thead><tr><th>VPN</th><th>PFN</th><th>valid</th><th>prot</th><th>ASID</th></tr></thead><tbody><tr><td>10</td><td>100</td><td>1</td><td>rwx</td><td>1</td></tr></tbody></table><h4 id=smaller-tables>Smaller Tables</h4><p>Using Multi-level Page Tables to store the mappings instead of linear tables with exponentially more size. This works when the address space is used sparsely.</p><h2 id=concurrency>Concurrency</h2><h3 id=abstraction--threads-locks-and-cvs>Abstraction : Threads, Locks and CVs</h3><dl><dt>Threads</dt><dd>A process can have multiple threads that can parallely execute while sharing the address space.<ul><li><code>clone(&amp;t)</code> : creates a new thread</li><li><code>join(&amp;t)</code> : waits for thread to join</li></ul></dd><dt>Locks</dt><dd>Only simple instructions available on the instruction set is executed atomically by the threads. Therefore to ensure atomicity while updating shared data structures a <strong>lock</strong> is used.<ul><li><code>lock(&amp;m)</code> : acquires the lock is available or else blocks till available</li><li><code>unlock(&amp;m)</code> : releases the lock</li></ul></dd></dl><h4 id=ways-to-create-locks>Ways to create Locks</h4><ul><li>Controlling Interrupts : Whenever lock is acquired disable interrupts and resume them when released. Dangerous as can&rsquo;t trust the programmer to use fairly.</li><li>Test and Set(Atomic Exchange) : <code>test-and-set</code> instruction in the instruction set to ensure atomicity, used to implement a spin-waiting lock. Very inefficient.</li><li>Compare and swap</li><li>Load-linked and store-conditional</li><li>Fetch and add</li><li>Yielding on fail: All the above implemented spinlocks. Simply yielding on failing to acquire performs better.</li><li>Waiting Queues to maintain fairness</li></ul><dl><dt>Conditional variables</dt><dd>A flag that wait for acquiring a lock till it is signaled by another process.<ul><li><code>wait(&amp;cv, &amp;m)</code> : Waits for conditional variable cv and releases the lock.</li><li><code>signal(&amp;cv)</code> : First to acquire the lock and be waiting on cv will execute</li><li><code>broadcast(&amp;cv)</code> : all waiting threads are scheduled once</li></ul></dd><dt>Semaphores</dt><dd>Hybrid of locks and conditional variables in one object that maintains an internal state of number of active threads.<ul><li><code>sem_wait(&amp;s)</code> : Waits for a Semaphore</li><li><code>sem_post(&amp;s)</code> : releases one semaphore</li></ul></dd></dl><h2 id=persistence>Persistence</h2><h3 id=abstraction--file-systems>Abstraction : File Systems</h3></article></main><footer id=footer><div><span>© 2019</span> - <span>2023</span></div><div><span>Powered by</span>
<a class=link href=https://gohugo.io/>Hugo</a>
<span>🍦 Theme</span>
<a class=link href=https://github.com/queensferryme/hugo-theme-texify>TeXify</a></div><div class=footnote><span>Follow me on <a class=link href=https://github.com/queensferryme>GitHub</a>,
<a class=link href=https://twitter.com/queensferryme>Twitter</a> or
<a class=link href=/index.xml>RSS</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></span></div></footer></div></body></html>