<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.102.3"><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico><title>Algorithms - Scrolls</title><meta name=keywords content="Computer-Science,Math"><meta property="og:title" content="Algorithms"><meta name=twitter:title content="Algorithms"><meta property="og:type" content="article"><meta property="og:url" content="https://adityakadoo.github.io/Scrolls/cp/algorithms/"><meta property="og:description" content="Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative int ternary_max(int[] a, int l, int r){ int res=0; while(l<=r){ int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]<a[m2]){ res = a[m2]; l = m1+1; } else if(a[m1]>a[m2]){ res = a[m1]; r = m2-1; } else{ res = a[m1]; l = m1+1; r = m2; } } return res; } Recursive int ternary_max(int[] a, int l, int r){ if(l==r) return a[0]; int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]<a[m2]){ return ternary_max(a,m1+1,r); else if(a[m1]>a[m2]){ return ternary_max(a,l,m2-1); else return ternary_max(a,m1+1,m2); } Proof $$n=r-l+1$$"><meta name=twitter:description content="Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative int ternary_max(int[] a, int l, int r){ int res=0; while(l<=r){ int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]<a[m2]){ res = a[m2]; l = m1+1; } else if(a[m1]>a[m2]){ res = a[m1]; r = m2-1; } else{ res = a[m1]; l = m1+1; r = m2; } } return res; } Recursive int ternary_max(int[] a, int l, int r){ if(l==r) return a[0]; int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]<a[m2]){ return ternary_max(a,m1+1,r); else if(a[m1]>a[m2]){ return ternary_max(a,l,m2-1); else return ternary_max(a,m1+1,m2); } Proof $$n=r-l+1$$"><meta name=twitter:card content="summary"><meta property="article:published_time" content="2022-09-02T09:46:58+05:30"><meta property="article:modified_time" content="2022-09-02T09:46:58+05:30"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://adityakadoo.github.io/Scrolls/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://adityakadoo.github.io/Scrolls/>Scrolls</a></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://adityakadoo.github.io/Scrolls/cp/algorithms/>Algorithms</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-09-02</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/computer-science>Computer-Science</a>&nbsp;<a href=/tags/math>Math</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=numerical-methods-3>Numerical Methods (3)</h2><h3 id=ternary-search>Ternary Search</h3><p>We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:</p><ol><li>The function strictly increases first, reaches maximum and then strictly decreases.</li><li>The function strictly decreases first, reaches minimum and then strictly increases.</li></ol><p>Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.</p><h4 id=implementation>Implementation</h4><h5 id=iterative>Iterative</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ternary_max</span>(<span style=color:#66d9ef>int</span>[] a, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(l<span style=color:#f92672>&lt;=</span>r){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m1 <span style=color:#f92672>=</span> l<span style=color:#f92672>+</span>(r<span style=color:#f92672>-</span>l)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m2 <span style=color:#f92672>=</span> r<span style=color:#f92672>-</span>(r<span style=color:#f92672>-</span>l)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(a[m1]<span style=color:#f92672>&lt;</span>a[m2]){
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> a[m2];
</span></span><span style=display:flex><span>            l <span style=color:#f92672>=</span> m1<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(a[m1]<span style=color:#f92672>&gt;</span>a[m2]){
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> a[m1];
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> m2<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> a[m1];
</span></span><span style=display:flex><span>            l <span style=color:#f92672>=</span> m1<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> m2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=recursive>Recursive</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ternary_max</span>(<span style=color:#66d9ef>int</span>[] a, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(l<span style=color:#f92672>==</span>r)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m1 <span style=color:#f92672>=</span> l<span style=color:#f92672>+</span>(r<span style=color:#f92672>-</span>l)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m2 <span style=color:#f92672>=</span> r<span style=color:#f92672>-</span>(r<span style=color:#f92672>-</span>l)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(a[m1]<span style=color:#f92672>&lt;</span>a[m2]){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ternary_max(a,m1<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,r);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(a[m1]<span style=color:#f92672>&gt;</span>a[m2]){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ternary_max(a,l,m2<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ternary_max(a,m1<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,m2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=proof>Proof</h4><p>$$n=r-l+1$$</p><h5 id=basis>Basis</h5><p>If $n=1$ then $a_0$ is the only and the maximum element</p><h5 id=induction>Induction</h5><p>Assuming our algorithm works for all arrays of size $\le n$. Consider an array $a$ with size $n+1$.
$$m_1 = l+\lfloor\dfrac{r-l}{3}\rfloor$$
$$m_2 = r-\lfloor\dfrac{r-l}{3}\rfloor$$</p><ul><li>If $a_{m_1}&lt;a_{m_2}$ then the maximum can&rsquo;t lie before $m_1$ therefore the max of $a[m_1+1:r]$ is the result.</li><li>If $a_{m_1}>a_{m_2}$ then the maximum can&rsquo;t lie after $m_2$ therefore the max of $a[l:m_2-1]$ is the result.</li><li>If $a_{m_1}=a_{m_2}$ then the maximum can&rsquo;t lie beyond $m_1$ or $m_2$ therefore the max of $a[m_1+1:m_2]$ is the result.</li></ul><p>In every case the new search space is of size less than $n+1$ and our algorithm will work on it.</p><h4 id=analysis>Analysis</h4><p>$$
T(n)=T(2n/3)+\mathcal{O}(1)
$$
Thus time complexity is $\mathcal O(\log n)$.</p><h3 id=newtons-method-for-finding-roots>Newton&rsquo;s method for finding roots</h3><p>Used to find root of a function $f(x)$ on some interval $[a,b]$. It is assumed that $f$ is continuous and differentiable over this interval.</p><h4 id=implementation-1>Implementation</h4><h5 id=to-find-real-square-root-of-a-number>To find real square root of a number</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>sqrt</span>(<span style=color:#66d9ef>float</span> n){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> f <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>] (<span style=color:#66d9ef>float</span> x){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x<span style=color:#f92672>*</span>x<span style=color:#f92672>-</span>n;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> f1 <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>] (<span style=color:#66d9ef>float</span> x){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>x;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> res<span style=color:#f92672>=</span>n,prev<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(res<span style=color:#f92672>-</span>prev<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>1e-9</span>){
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> res;
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> res<span style=color:#f92672>-</span>f(res)<span style=color:#f92672>/</span>f1(res);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=to-find-integer-part-of-square-root-of-a-number>To find integer part of square root of a number</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sqrt</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,nx<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> decreased <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(x <span style=color:#f92672>!=</span> nx <span style=color:#f92672>&amp;&amp;</span> (nx <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>decreased)) {
</span></span><span style=display:flex><span>        decreased <span style=color:#f92672>=</span> nx <span style=color:#f92672>&lt;</span> x;
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> nx;
</span></span><span style=display:flex><span>        nx <span style=color:#f92672>=</span> (x <span style=color:#f92672>+</span> n <span style=color:#f92672>/</span> x) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=proof-1>Proof</h4><p>It converges towards the root with every iteration.</p><p>$$
|x_{i+1}-\sqrt{n}|=|\dfrac{x_i+\frac{n}{x_i}}{2}-\sqrt{n}|=\dfrac{|(\sqrt{x_i}-\dfrac{\sqrt{n}}{\sqrt{x_i}})^2|}{2}\le|x_i-\sqrt{n}|
$$</p><h4 id=analysis-1>Analysis</h4><p>For $n$-digit precision requirement the complexity is $\mathcal O(n)$.</p><h3 id=simpsons-formula>Simpson&rsquo;s Formula</h3><p>Used to calculate the integral of a funtion $f$ over the interval $[a,b]$.</p><h4 id=implementation-2>Implementation</h4><p>Here $f(x)$ is some pre-defined function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define N 1000*1000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>integrate</span>(<span style=color:#66d9ef>float</span> a,<span style=color:#66d9ef>float</span> b){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> h <span style=color:#f92672>=</span> (b<span style=color:#f92672>-</span>a)<span style=color:#f92672>/</span>N;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> f <span style=color:#f92672>=</span> [] (<span style=color:#66d9ef>float</span> x) {...};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> res <span style=color:#f92672>=</span> f(a)<span style=color:#f92672>+</span>f(b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>N;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> x <span style=color:#f92672>=</span> a<span style=color:#f92672>+</span>h<span style=color:#f92672>*</span>(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            res <span style=color:#f92672>+=</span> f(x)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            res <span style=color:#f92672>+=</span> f(x)<span style=color:#f92672>*</span><span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    res <span style=color:#f92672>*=</span> h<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=proof-2>Proof</h4><p>Let $n$ be some natural number. We divide the integration segment $[a,b]$ into $2n$ equal parts:
$$
x_i=a+ih,\ i=0\dots2n,\\ h=\dfrac{b-a}{2n}
$$
Now we calculate the integral separately on each of the segments $[x_{2i-2},x_{2i}$, $i=1\dots n$ and then add all the values.</p><p>So, suppose we consider the next segment $[x_{2i-2},x_{2i}]$, $i=1\dots n$. Replace the function $f(x)$ on it with a parabola $P(x)$ passing through 3 points $(x_{2i-2},x_{2i-1},x_{2i})$. Such a parabola always exists and is unique; it can be found analytically. For instance we could construct it using the Lagrange polynomial interpolation. The only remaining thing left to do is to integrate this polynomial. If you do this for a general function $f$, you receive a remarkably simple expression:
$$
\int_{x_{2i-2}}^{x_{2i}}f(x)dx\approx\int_{x_{2i-2}}^{x_{2i}}P(x)dx=(f(x_{2i-2})+4f(x_{2i-1})+f(x_{2i}))\frac{h}{3}
$$
Adding these values over all segments, we obtain the final Simpson&rsquo;s formula:
$$
\int_a^bf(x)dx\approx(f(x_0)+4f(x_1)+2f(x_2)+\cdots+4f(x_{2N-1})+f(x_{2N}))\frac{h}{3}
$$</p><h4 id=analysis-2>Analysis</h4><p>Only depends on the number of divisions thus $\mathcal O(n)$.</p><h2 id=dynamic-programming-4>Dynamic Programming (4)</h2><h2 id=combinatorics-10>Combinatorics (10)</h2><h2 id=data-structures-10>Data Structures (10)</h2><h2 id=string-processing-12>String Processing (12)</h2><h2 id=linear-algebra-4>Linear Algebra (4)</h2><h2 id=geometry-23>Geometry (23)</h2><h2 id=algebra-27>Algebra (27)</h2><h2 id=graphs-44>Graphs (44)</h2><h2 id=miscellaneous-12>Miscellaneous (12)</h2></div></article></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/Scrolls/tags/computer-science/>Computer-Science</a></span>
<span><a href=/Scrolls/tags/machine-learning/>Machine-Learning</a></span>
<span><a href=/Scrolls/tags/math/>Math</a></span>
<span><a href=/Scrolls/tags/programming-languages/>Programming-Languages</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#numerical-methods-3>Numerical Methods (3)</a><ul><li><a href=#ternary-search>Ternary Search</a></li><li><a href=#newtons-method-for-finding-roots>Newton&rsquo;s method for finding roots</a></li><li><a href=#simpsons-formula>Simpson&rsquo;s Formula</a></li></ul></li><li><a href=#dynamic-programming-4>Dynamic Programming (4)</a></li><li><a href=#combinatorics-10>Combinatorics (10)</a></li><li><a href=#data-structures-10>Data Structures (10)</a></li><li><a href=#string-processing-12>String Processing (12)</a></li><li><a href=#linear-algebra-4>Linear Algebra (4)</a></li><li><a href=#geometry-23>Geometry (23)</a></li><li><a href=#algebra-27>Algebra (27)</a></li><li><a href=#graphs-44>Graphs (44)</a></li><li><a href=#miscellaneous-12>Miscellaneous (12)</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/Scrolls/tags/computer-science/>Computer-Science</a></span>
<span><a href=/Scrolls/tags/machine-learning/>Machine-Learning</a></span>
<span><a href=/Scrolls/tags/math/>Math</a></span>
<span><a href=/Scrolls/tags/programming-languages/>Programming-Languages</a></span></div></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2022
<a href=https://adityakadoo.github.io/Scrolls/></a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/Scrolls/assets/js/fuji.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script>
<script>renderMathInElement(document.querySelector("div.content"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>