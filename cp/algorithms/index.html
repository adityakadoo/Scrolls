<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="Aditya Kadoo"><meta name=description content="Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative 1int ternary_max(int[] a, int l, int r){ 2 int res=0; 3 while(l<=r){ 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 res = a[m2]; 8 l = m1+1; 9 } 10 else if(a[m1]>a[m2]){ 11 res = a[m1]; 12 r = m2-1; 13 } 14 else{ 15 res = a[m1]; 16 l = m1+1; 17 r = m2; 18 } 19 } 20 return res; 21} Recursive 1int ternary_max(int[] a, int l, int r){ 2 if(l==r) 3 return a[0]; 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 return ternary_max(a,m1+1,r); 8 else if(a[m1]>a[m2]){ 9 return ternary_max(a,l,m2-1); 10 else 11 return ternary_max(a,m1+1,m2); 12} Proof $$n=r-l+1$$"><link rel=icon href=https://adityakadoo.github.io/Scrolls/favicon.ico><meta name=keywords content=" hugo  latex  theme "><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script><meta property="og:title" content="Algorithms"><meta property="og:description" content="Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative 1int ternary_max(int[] a, int l, int r){ 2 int res=0; 3 while(l<=r){ 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 res = a[m2]; 8 l = m1+1; 9 } 10 else if(a[m1]>a[m2]){ 11 res = a[m1]; 12 r = m2-1; 13 } 14 else{ 15 res = a[m1]; 16 l = m1+1; 17 r = m2; 18 } 19 } 20 return res; 21} Recursive 1int ternary_max(int[] a, int l, int r){ 2 if(l==r) 3 return a[0]; 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 return ternary_max(a,m1+1,r); 8 else if(a[m1]>a[m2]){ 9 return ternary_max(a,l,m2-1); 10 else 11 return ternary_max(a,m1+1,m2); 12} Proof $$n=r-l+1$$"><meta property="og:type" content="article"><meta property="og:url" content="https://adityakadoo.github.io/Scrolls/cp/algorithms/"><meta property="article:section" content="cp"><meta property="article:published_time" content="2022-09-02T09:46:58+05:30"><meta property="article:modified_time" content="2022-09-02T09:46:58+05:30"><link rel=canonical href=https://adityakadoo.github.io/Scrolls/cp/algorithms/><meta itemprop=name content="Algorithms"><meta itemprop=description content="Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative 1int ternary_max(int[] a, int l, int r){ 2 int res=0; 3 while(l<=r){ 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 res = a[m2]; 8 l = m1+1; 9 } 10 else if(a[m1]>a[m2]){ 11 res = a[m1]; 12 r = m2-1; 13 } 14 else{ 15 res = a[m1]; 16 l = m1+1; 17 r = m2; 18 } 19 } 20 return res; 21} Recursive 1int ternary_max(int[] a, int l, int r){ 2 if(l==r) 3 return a[0]; 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 return ternary_max(a,m1+1,r); 8 else if(a[m1]>a[m2]){ 9 return ternary_max(a,l,m2-1); 10 else 11 return ternary_max(a,m1+1,m2); 12} Proof $$n=r-l+1$$"><meta itemprop=datePublished content="2022-09-02T09:46:58+05:30"><meta itemprop=dateModified content="2022-09-02T09:46:58+05:30"><meta itemprop=wordCount content="714"><meta itemprop=keywords content="Computer-Science,Math,"><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/common.css><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/content.css><title>Algorithms - Scrolls</title>
<meta name=twitter:card content="summary"><meta name=twitter:title content="Algorithms"><meta name=twitter:description content="Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative 1int ternary_max(int[] a, int l, int r){ 2 int res=0; 3 while(l<=r){ 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 res = a[m2]; 8 l = m1+1; 9 } 10 else if(a[m1]>a[m2]){ 11 res = a[m1]; 12 r = m2-1; 13 } 14 else{ 15 res = a[m1]; 16 l = m1+1; 17 r = m2; 18 } 19 } 20 return res; 21} Recursive 1int ternary_max(int[] a, int l, int r){ 2 if(l==r) 3 return a[0]; 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]<a[m2]){ 7 return ternary_max(a,m1+1,r); 8 else if(a[m1]>a[m2]){ 9 return ternary_max(a,l,m2-1); 10 else 11 return ternary_max(a,m1+1,m2); 12} Proof $$n=r-l+1$$"><link rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/single.css></head><body><div id=wrapper><header id=header><h1>Algorithms</h1><nav><span class=nav-bar-item><a class=link href></a></span></nav><p></p></header><main id=main class=post><article class=content><div class=tableofcontent></div><h2 id=numerical-methods-3>Numerical Methods (3)</h2><h3 id=ternary-search>Ternary Search</h3><p>We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:</p><ol><li>The function strictly increases first, reaches maximum and then strictly decreases.</li><li>The function strictly decreases first, reaches minimum and then strictly increases.</li></ol><p>Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.</p><h4 id=implementation>Implementation</h4><h5 id=iterative>Iterative</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=kt>int</span> <span class=nf>ternary_max</span><span class=p>(</span><span class=kt>int</span><span class=p>[]</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=kt>int</span> <span class=n>res</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>l</span><span class=o>&lt;=</span><span class=n>r</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>        <span class=kt>int</span> <span class=n>m1</span> <span class=o>=</span> <span class=n>l</span><span class=o>+</span><span class=p>(</span><span class=n>r</span><span class=o>-</span><span class=n>l</span><span class=p>)</span><span class=o>/</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=kt>int</span> <span class=n>m2</span> <span class=o>=</span> <span class=n>r</span><span class=o>-</span><span class=p>(</span><span class=n>r</span><span class=o>-</span><span class=n>l</span><span class=p>)</span><span class=o>/</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>m1</span><span class=p>]</span><span class=o>&lt;</span><span class=n>a</span><span class=p>[</span><span class=n>m2</span><span class=p>]){</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>            <span class=n>res</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>m2</span><span class=p>];</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>            <span class=n>l</span> <span class=o>=</span> <span class=n>m1</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>m1</span><span class=p>]</span><span class=o>&gt;</span><span class=n>a</span><span class=p>[</span><span class=n>m2</span><span class=p>]){</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>            <span class=n>res</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>m1</span><span class=p>];</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=n>m2</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>        <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>            <span class=n>res</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>m1</span><span class=p>];</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>            <span class=n>l</span> <span class=o>=</span> <span class=n>m1</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=n>m2</span><span class=p>;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=ln>21</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=recursive>Recursive</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=kt>int</span> <span class=nf>ternary_max</span><span class=p>(</span><span class=kt>int</span><span class=p>[]</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>l</span><span class=o>==</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=k>return</span> <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=kt>int</span> <span class=n>m1</span> <span class=o>=</span> <span class=n>l</span><span class=o>+</span><span class=p>(</span><span class=n>r</span><span class=o>-</span><span class=n>l</span><span class=p>)</span><span class=o>/</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=kt>int</span> <span class=n>m2</span> <span class=o>=</span> <span class=n>r</span><span class=o>-</span><span class=p>(</span><span class=n>r</span><span class=o>-</span><span class=n>l</span><span class=p>)</span><span class=o>/</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>m1</span><span class=p>]</span><span class=o>&lt;</span><span class=n>a</span><span class=p>[</span><span class=n>m2</span><span class=p>]){</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>        <span class=k>return</span> <span class=n>ternary_max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>m1</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>m1</span><span class=p>]</span><span class=o>&gt;</span><span class=n>a</span><span class=p>[</span><span class=n>m2</span><span class=p>]){</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=k>return</span> <span class=n>ternary_max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>l</span><span class=p>,</span><span class=n>m2</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=k>return</span> <span class=n>ternary_max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>m1</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>m2</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=proof>Proof</h4><p>$$n=r-l+1$$</p><h5 id=basis>Basis</h5><p>If $n=1$ then $a_0$ is the only and the maximum element</p><h5 id=induction>Induction</h5><p>Assuming our algorithm works for all arrays of size $\le n$. Consider an array $a$ with size $n+1$.
$$m_1 = l+\lfloor\dfrac{r-l}{3}\rfloor$$
$$m_2 = r-\lfloor\dfrac{r-l}{3}\rfloor$$</p><ul><li>If $a_{m_1}&lt;a_{m_2}$ then the maximum can&rsquo;t lie before $m_1$ therefore the max of $a[m_1+1:r]$ is the result.</li><li>If $a_{m_1}>a_{m_2}$ then the maximum can&rsquo;t lie after $m_2$ therefore the max of $a[l:m_2-1]$ is the result.</li><li>If $a_{m_1}=a_{m_2}$ then the maximum can&rsquo;t lie beyond $m_1$ or $m_2$ therefore the max of $a[m_1+1:m_2]$ is the result.</li></ul><p>In every case the new search space is of size less than $n+1$ and our algorithm will work on it.</p><h4 id=analysis>Analysis</h4><p>$$
T(n)=T(2n/3)+\mathcal{O}(1)
$$
Thus time complexity is $\mathcal O(\log n)$.</p><h3 id=newtons-method-for-finding-roots>Newton&rsquo;s method for finding roots</h3><p>Used to find root of a function $f(x)$ on some interval $[a,b]$. It is assumed that $f$ is continuous and differentiable over this interval.</p><h4 id=implementation-1>Implementation</h4><h5 id=to-find-real-square-root-of-a-number>To find real square root of a number</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=kt>float</span> <span class=nf>sqrt</span><span class=p>(</span><span class=kt>float</span> <span class=n>n</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]</span> <span class=p>(</span><span class=kt>float</span> <span class=n>x</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=k>return</span> <span class=n>x</span><span class=o>*</span><span class=n>x</span><span class=o>-</span><span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=k>auto</span> <span class=n>f1</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]</span> <span class=p>(</span><span class=kt>float</span> <span class=n>x</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>        <span class=k>return</span> <span class=mi>2</span><span class=o>*</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=kt>float</span> <span class=n>res</span><span class=o>=</span><span class=n>n</span><span class=p>,</span><span class=n>prev</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>res</span><span class=o>-</span><span class=n>prev</span><span class=o>&gt;</span><span class=mf>1e-9</span><span class=p>){</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>        <span class=n>prev</span> <span class=o>=</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=n>res</span> <span class=o>=</span> <span class=n>res</span><span class=o>-</span><span class=n>f</span><span class=p>(</span><span class=n>res</span><span class=p>)</span><span class=o>/</span><span class=n>f1</span><span class=p>(</span><span class=n>res</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=ln>14</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=to-find-integer-part-of-square-root-of-a-number>To find integer part of square root of a number</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=kt>int</span> <span class=nf>sqrt</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span><span class=n>nx</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=kt>bool</span> <span class=n>decreased</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>x</span> <span class=o>!=</span> <span class=n>nx</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>nx</span> <span class=o>&lt;=</span> <span class=n>x</span> <span class=o>||</span> <span class=o>!</span><span class=n>decreased</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=n>decreased</span> <span class=o>=</span> <span class=n>nx</span> <span class=o>&lt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=n>nx</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>        <span class=n>nx</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>n</span> <span class=o>/</span> <span class=n>x</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=proof-1>Proof</h4><p>It converges towards the root with every iteration.</p><p>$$
|x_{i+1}-\sqrt{n}|=|\dfrac{x_i+\frac{n}{x_i}}{2}-\sqrt{n}|=\dfrac{|(\sqrt{x_i}-\dfrac{\sqrt{n}}{\sqrt{x_i}})^2|}{2}\le|x_i-\sqrt{n}|
$$</p><h4 id=analysis-1>Analysis</h4><p>For $n$-digit precision requirement the complexity is $\mathcal O(n)$.</p><h3 id=simpsons-formula>Simpson&rsquo;s Formula</h3><p>Used to calculate the integral of a funtion $f$ over the interval $[a,b]$.</p><h4 id=implementation-2>Implementation</h4><p>Here $f(x)$ is some pre-defined function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#define N 1000*1000
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=kt>float</span> <span class=nf>integrate</span><span class=p>(</span><span class=kt>float</span> <span class=n>a</span><span class=p>,</span><span class=kt>float</span> <span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=kt>float</span> <span class=n>h</span> <span class=o>=</span> <span class=p>(</span><span class=n>b</span><span class=o>-</span><span class=n>a</span><span class=p>)</span><span class=o>/</span><span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>(</span><span class=kt>float</span> <span class=n>x</span><span class=p>)</span> <span class=p>{...};</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=kt>float</span> <span class=n>res</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>a</span><span class=p>)</span><span class=o>+</span><span class=n>f</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>N</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>        <span class=kt>float</span> <span class=n>x</span> <span class=o>=</span> <span class=n>a</span><span class=o>+</span><span class=n>h</span><span class=o>*</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>%</span><span class=mi>2</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>            <span class=n>res</span> <span class=o>+=</span> <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>            <span class=n>res</span> <span class=o>+=</span> <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=o>*</span><span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=n>res</span> <span class=o>*=</span> <span class=n>h</span><span class=o>/</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=ln>16</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=proof-2>Proof</h4><p>Let $n$ be some natural number. We divide the integration segment $[a,b]$ into $2n$ equal parts:
$$
x_i=a+ih,\ i=0\dots2n,\\ h=\dfrac{b-a}{2n}
$$
Now we calculate the integral separately on each of the segments $[x_{2i-2},x_{2i}$, $i=1\dots n$ and then add all the values.</p><p>So, suppose we consider the next segment $[x_{2i-2},x_{2i}]$, $i=1\dots n$. Replace the function $f(x)$ on it with a parabola $P(x)$ passing through 3 points $(x_{2i-2},x_{2i-1},x_{2i})$. Such a parabola always exists and is unique; it can be found analytically. For instance we could construct it using the Lagrange polynomial interpolation. The only remaining thing left to do is to integrate this polynomial. If you do this for a general function $f$, you receive a remarkably simple expression:
$$
\int_{x_{2i-2}}^{x_{2i}}f(x)dx\approx\int_{x_{2i-2}}^{x_{2i}}P(x)dx=(f(x_{2i-2})+4f(x_{2i-1})+f(x_{2i}))\frac{h}{3}
$$
Adding these values over all segments, we obtain the final Simpson&rsquo;s formula:
$$
\int_a^bf(x)dx\approx(f(x_0)+4f(x_1)+2f(x_2)+\cdots+4f(x_{2N-1})+f(x_{2N}))\frac{h}{3}
$$</p><h4 id=analysis-2>Analysis</h4><p>Only depends on the number of divisions thus $\mathcal O(n)$.</p><h2 id=dynamic-programming-4>Dynamic Programming (4)</h2><h2 id=combinatorics-10>Combinatorics (10)</h2><h2 id=data-structures-10>Data Structures (10)</h2><h2 id=string-processing-12>String Processing (12)</h2><h2 id=linear-algebra-4>Linear Algebra (4)</h2><h2 id=geometry-23>Geometry (23)</h2><h2 id=algebra-27>Algebra (27)</h2><h2 id=graphs-44>Graphs (44)</h2><h2 id=miscellaneous-12>Miscellaneous (12)</h2></article></main><footer id=footer><div><span>© 2022</span> - <span>2023</span></div><div><span>Powered by </span><a class=link href=https://gohugo.io/>Hugo</a>
<span>🍦 Theme </span><a class=link href=https://github.com/queensferryme/hugo-theme-texify>TeXify</a></div><div class=footnote><span>Follow me on <a class=link href=https://github.com/adityakadoo>GitHub</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></span></div></footer></div><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/syntax.css></body></html>