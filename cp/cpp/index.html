<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="Aditya Kadoo"><meta name=description content="Basic Utilities Initializer lists 1int values[] {1, 2, 3}; 2std::vector<int> v {1, 2, 4, 8, 16}; 3std::vector<std::string> cities { 4 &#34;Berlin&#34;, &#34;New York&#34;, &#34;London&#34;, &#34;Braunschweig&#34;, &#34;Cairo&#34;, &#34;Cologne&#34; 5}; 6std::complex<double> c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container 1for (auto& elem : vec) { 2 elem *= 3; 3} Looping through an initializer list 1for (int i : {1, 2, 3, 4, 5}) { 2 std::cout<< i << std::endl; 3} Lambda functions 1int x=0; 2int y=42; 3auto f1 = [=, &amp;y] (std::string s) { 4 cout<<s<<&#34;\n&#34;; 5 x++; // not very effective 6 y++; // super effective 7} 8auto f2 = [=] (std::string s) { 9 cout<<s<<&#34;\n&#34;; 10 x++; // not very effective 11 y++; // not very effective 12} 13auto f3 = [&] (std::string s) { 14 cout<<s<<&#34;\n&#34;; 15 x++; // super effective 16 y++; // super effective 17} Numeric Limits 1cout << &#34;max(short): &#34; << numeric_limits<short>::max() << endl; 2cout << &#34;max(int): &#34; << numeric_limits<int>::max() << endl; 3cout << &#34;max(long): &#34; << numeric_limits<long>::max() << endl; Pair 1std::pair<T1, T2> p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p."><link rel=icon href=https://adityakadoo.github.io/Scrolls/favicon.ico><meta name=keywords content=" hugo  latex  theme "><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script><meta property="og:title" content="C++ - Standard Template Library"><meta property="og:description" content="Basic Utilities Initializer lists 1int values[] {1, 2, 3}; 2std::vector<int> v {1, 2, 4, 8, 16}; 3std::vector<std::string> cities { 4 &#34;Berlin&#34;, &#34;New York&#34;, &#34;London&#34;, &#34;Braunschweig&#34;, &#34;Cairo&#34;, &#34;Cologne&#34; 5}; 6std::complex<double> c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container 1for (auto& elem : vec) { 2 elem *= 3; 3} Looping through an initializer list 1for (int i : {1, 2, 3, 4, 5}) { 2 std::cout<< i << std::endl; 3} Lambda functions 1int x=0; 2int y=42; 3auto f1 = [=, &amp;y] (std::string s) { 4 cout<<s<<&#34;\n&#34;; 5 x++; // not very effective 6 y++; // super effective 7} 8auto f2 = [=] (std::string s) { 9 cout<<s<<&#34;\n&#34;; 10 x++; // not very effective 11 y++; // not very effective 12} 13auto f3 = [&] (std::string s) { 14 cout<<s<<&#34;\n&#34;; 15 x++; // super effective 16 y++; // super effective 17} Numeric Limits 1cout << &#34;max(short): &#34; << numeric_limits<short>::max() << endl; 2cout << &#34;max(int): &#34; << numeric_limits<int>::max() << endl; 3cout << &#34;max(long): &#34; << numeric_limits<long>::max() << endl; Pair 1std::pair<T1, T2> p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p."><meta property="og:type" content="article"><meta property="og:url" content="https://adityakadoo.github.io/Scrolls/cp/cpp/"><meta property="article:section" content="cp"><meta property="article:published_time" content="2022-08-20T12:27:03+05:30"><meta property="article:modified_time" content="2022-08-20T12:27:03+05:30"><link rel=canonical href=https://adityakadoo.github.io/Scrolls/cp/cpp/><meta itemprop=name content="C++ - Standard Template Library"><meta itemprop=description content="Basic Utilities Initializer lists 1int values[] {1, 2, 3}; 2std::vector<int> v {1, 2, 4, 8, 16}; 3std::vector<std::string> cities { 4 &#34;Berlin&#34;, &#34;New York&#34;, &#34;London&#34;, &#34;Braunschweig&#34;, &#34;Cairo&#34;, &#34;Cologne&#34; 5}; 6std::complex<double> c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container 1for (auto& elem : vec) { 2 elem *= 3; 3} Looping through an initializer list 1for (int i : {1, 2, 3, 4, 5}) { 2 std::cout<< i << std::endl; 3} Lambda functions 1int x=0; 2int y=42; 3auto f1 = [=, &amp;y] (std::string s) { 4 cout<<s<<&#34;\n&#34;; 5 x++; // not very effective 6 y++; // super effective 7} 8auto f2 = [=] (std::string s) { 9 cout<<s<<&#34;\n&#34;; 10 x++; // not very effective 11 y++; // not very effective 12} 13auto f3 = [&] (std::string s) { 14 cout<<s<<&#34;\n&#34;; 15 x++; // super effective 16 y++; // super effective 17} Numeric Limits 1cout << &#34;max(short): &#34; << numeric_limits<short>::max() << endl; 2cout << &#34;max(int): &#34; << numeric_limits<int>::max() << endl; 3cout << &#34;max(long): &#34; << numeric_limits<long>::max() << endl; Pair 1std::pair<T1, T2> p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p."><meta itemprop=datePublished content="2022-08-20T12:27:03+05:30"><meta itemprop=dateModified content="2022-08-20T12:27:03+05:30"><meta itemprop=wordCount content="1068"><meta itemprop=keywords content="Programming-Languages,Computer-Science,"><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/common.css><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/content.css><title>C++ - Standard Template Library - Scrolls</title>
<meta name=twitter:card content="summary"><meta name=twitter:title content="C++ - Standard Template Library"><meta name=twitter:description content="Basic Utilities Initializer lists 1int values[] {1, 2, 3}; 2std::vector<int> v {1, 2, 4, 8, 16}; 3std::vector<std::string> cities { 4 &#34;Berlin&#34;, &#34;New York&#34;, &#34;London&#34;, &#34;Braunschweig&#34;, &#34;Cairo&#34;, &#34;Cologne&#34; 5}; 6std::complex<double> c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container 1for (auto& elem : vec) { 2 elem *= 3; 3} Looping through an initializer list 1for (int i : {1, 2, 3, 4, 5}) { 2 std::cout<< i << std::endl; 3} Lambda functions 1int x=0; 2int y=42; 3auto f1 = [=, &amp;y] (std::string s) { 4 cout<<s<<&#34;\n&#34;; 5 x++; // not very effective 6 y++; // super effective 7} 8auto f2 = [=] (std::string s) { 9 cout<<s<<&#34;\n&#34;; 10 x++; // not very effective 11 y++; // not very effective 12} 13auto f3 = [&] (std::string s) { 14 cout<<s<<&#34;\n&#34;; 15 x++; // super effective 16 y++; // super effective 17} Numeric Limits 1cout << &#34;max(short): &#34; << numeric_limits<short>::max() << endl; 2cout << &#34;max(int): &#34; << numeric_limits<int>::max() << endl; 3cout << &#34;max(long): &#34; << numeric_limits<long>::max() << endl; Pair 1std::pair<T1, T2> p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p."><link rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/single.css></head><body><div id=wrapper><header id=header><h1>C++ - Standard Template Library</h1><nav><span class=nav-bar-item><a class=link href></a></span></nav><p></p></header><main id=main class=post><article class=content><div class=tableofcontent></div><h2 id=basic-utilities>Basic Utilities</h2><h3 id=initializer-lists>Initializer lists</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=kt>int</span> <span class=n>values</span><span class=p>[]</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>16</span><span class=p>};</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>cities</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=s>&#34;Berlin&#34;</span><span class=p>,</span> <span class=s>&#34;New York&#34;</span><span class=p>,</span> <span class=s>&#34;London&#34;</span><span class=p>,</span> <span class=s>&#34;Braunschweig&#34;</span><span class=p>,</span> <span class=s>&#34;Cairo&#34;</span><span class=p>,</span> <span class=s>&#34;Cologne&#34;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>complex</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>c</span><span class=p>{</span><span class=mf>4.0</span><span class=p>,</span><span class=mf>3.0</span><span class=p>};</span> <span class=c1>// equivalent to c(4.0,3.0)
</span></span></span></code></pre></div><h3 id=range-based-for-loops>Range-based <em>for</em> loops</h3><ul><li>Looping through a container<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>elem</span> <span class=p>:</span> <span class=n>vec</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=n>elem</span> <span class=o>*=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>Looping through an initializer list<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>i</span> <span class=p>:</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul><h3 id=lambda-functions>Lambda functions</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=kt>int</span> <span class=n>x</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=kt>int</span> <span class=n>y</span><span class=o>=</span><span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=k>auto</span> <span class=n>f1</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>]</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>s</span><span class=o>&lt;&lt;</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=n>x</span><span class=o>++</span><span class=p>;</span> <span class=c1>// not very effective
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=c1></span>    <span class=n>y</span><span class=o>++</span><span class=p>;</span> <span class=c1>// super effective
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=k>auto</span> <span class=n>f2</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>s</span><span class=o>&lt;&lt;</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=n>x</span><span class=o>++</span><span class=p>;</span> <span class=c1>// not very effective
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span>    <span class=n>y</span><span class=o>++</span><span class=p>;</span> <span class=c1>// not very effective
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=ln>13</span><span class=cl><span class=k>auto</span> <span class=n>f3</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>]</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>s</span><span class=o>&lt;&lt;</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>    <span class=n>x</span><span class=o>++</span><span class=p>;</span> <span class=c1>// super effective
</span></span></span><span class=line><span class=ln>16</span><span class=cl><span class=c1></span>    <span class=n>y</span><span class=o>++</span><span class=p>;</span> <span class=c1>// super effective
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=numeric-limits>Numeric Limits</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(short): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>short</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(int): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(long): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>long</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=pair>Pair</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>&gt;</span> <span class=n>p</span><span class=p>(</span><span class=n>e1</span><span class=p>,</span><span class=n>e2</span><span class=p>);</span>
</span></span></code></pre></div><table><thead><tr><th>Operation</th><th>Effect</th><th>Complexity</th></tr></thead><tbody><tr><td><code>make_pair(e1,e2)</code></td><td>Returns a pair using types and values of e1 and e2</td><td>$\mathcal{O}(1)$</td></tr><tr><td><code>p.first</code></td><td>Returns reference to first value</td><td>$\mathcal{O}(1)$</td></tr><tr><td><code>p.second</code></td><td>Returns reference to second value</td><td>$\mathcal{O}(1)$</td></tr><tr><td><code>p1==p2</code></td><td>Returns <code>p1.first==p2.first && p1.second==p2.second</code></td><td>$\mathcal{O}(1)$</td></tr><tr><td><code>p1&lt;p2</code></td><td>Compares first values and if equal second of both values</td><td>$\mathcal{O}(1)$</td></tr><tr><td><code>swap(p1,p2)</code></td><td>Swaps data of p1 and p2</td><td>$\mathcal{O}(1)$</td></tr></tbody></table><h3 id=tuple>Tuple</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span><span class=n>T2</span><span class=p>,</span><span class=n>T3</span><span class=p>,...</span><span class=n>Tk</span><span class=o>&gt;</span> <span class=n>t</span><span class=p>(</span><span class=n>e1</span><span class=p>,</span><span class=n>e2</span><span class=p>,</span><span class=n>e3</span><span class=p>,...,</span><span class=n>ek</span><span class=p>);</span>
</span></span></code></pre></div><table><thead><tr><th>Operation</th><th>Effect</th><th>Complexity</th></tr></thead><tbody><tr><td><code>make_tuple(e1,e2,..., ek)</code></td><td>Returns a tuple using types and values of e1, &mldr;, ek</td><td>$\mathcal{O}(k)$</td></tr><tr><td><code>get&lt;i>(t)</code></td><td>Returns reference to the ith value</td><td>$\mathcal{O}(1)$</td></tr><tr><td><code>t1==t2</code></td><td>Returns whether all elements of t1 are equal to t2</td><td>$\mathcal{O}(k)$</td></tr><tr><td><code>t1&lt;t2</code></td><td>Compares elements of t1 and t2 lexicographically</td><td>$\mathcal{O}(k)$</td></tr><tr><td><code>swap(t1,t2)</code></td><td>Swaps data of t1 and t2</td><td>$\mathcal{O}(k)$</td></tr></tbody></table><h2 id=stl-structure>STL Structure</h2><p>STL has 4 most important design components; containers, iterators, algorithms and function objects. These can be used to separate data structures from algorithms and provides a generic API for combining the two.</p><h3 id=containers>Containers</h3><p>There are 3 kinds of containers:</p><h4 id=sequence-containers>Sequence containers</h4><p>These are <em>ordered collections</em> where every element has a certain position. These containers are usually implemented using <em>arrays</em> or <em>linked lists</em>.</p><ol><li><strong>Vector</strong>: Vector manages it&rsquo;s elements in the form of a dynamic array that can grow in one direction with random access.</li><li><strong>Deque</strong>: It is a dynamic array that can grow in both directions.</li><li><strong>Array</strong>: A container of fixed size with random access.</li><li><strong>List</strong>: It is a doubly linked list of elements with insertion or deletion at any position.</li><li><strong>Forward List</strong>: It is a singly linked list without backward operations of List.</li></ol><h4 id=associative-containers>Associative containers</h4><p>These are <em>sorted collections</em> where the position of every element depends on its value. These containers are usually implemented using <em>binary trees</em>.</p><ol><li><strong>Set</strong>: A set is a collection in which elements are sorted according to their own values. Each element may occur only once, so duplicates are not allowed.</li><li><strong>Multiset</strong>: A multiset is the same as a set except that duplicates are allowed. Thus, a multiset may contain multiple elements that have the same value.</li><li><strong>Map</strong>: A map contains elements that are key/value pairs. Each element has a key that is the basis for the sorting criterion and a value. Each key may occur only once, so duplicate keys are not allowed. A map can also be used as an associative array, an array that has an arbitrary index type.</li><li><strong>Multimap</strong>: A multimap is the same as a map except that duplicates are allowed. Thus, a multimap may contain multiple elements that have the same key. A multimap can also be used as dictionary.</li></ol><h4 id=unordered-associative-containers>Unordered (associative) containers</h4><p>These are <em>unordered collections</em> where the position of an element doesn&rsquo;t matter. These containers are usually implemented using <em>hash tables</em>.</p><ol><li><strong>Unordered set</strong>: An unordered set is a collection of unordered elements, where each element may occur only once. Thus, duplicates are not allowed.</li><li><strong>Unordered multisets</strong>: An unordered multiset is the same as an unordered set except that duplicates are allowed. Thus, an unordered multiset may contain multiple elements that have the same value.</li><li><strong>Unordered map</strong>: An unordered map contains elements that are key/value pairs. Each key may occur only once, so duplicate keys are not allowed. An unordered map can also be used as an associative array, an array that has an arbitrary index type.</li><li><strong>Unordered multimap</strong>: An unordered multimap is the same as an unordered map except that duplicates are allowed. Thus, an unordered multimap may contain multiple elements that have the same key. An unordered multimap can also be used as dictionary.</li></ol><h4 id=container-adapters>Container Adapters</h4><ol><li><strong>Stack</strong>: A stack (the name says it all) manages its elements by the LIFO (last-in-first-out) policy.</li><li><strong>Queue</strong>: A queue manages its elements by the FIFO (first-in-first-out) policy. That is, it is an ordinary buffer.</li><li><strong>Priority queue</strong>: A priority queue is a container in which the elements may have different priorities.</li></ol><h3 id=iterators>Iterators</h3><p>We need a concept of an object that represents positions of elements in a container. Objects that fulfill this concept are called <em><strong>iterators</strong></em>. Following are the operations that one can perform using these iterators:</p><ul><li>Operator <code>*</code> returns the element of the current position. If the elements have members, you can use operator <code>-></code> to access those members directly from the iterator.</li><li>Operator <code>++</code> lets the iterator step forward to the next element. Most iterators also allow stepping backward by using operator <code>--</code>.</li><li>Operators <code>==</code> and <code>!=</code> return whether two iterators represent the same position.</li><li>Operator <code>=</code> assigns an iterator.</li></ul><p>Apart from this every container class also provides following methods:</p><ul><li><code>begin()</code> returns an iterator that represents the beginning of the elements in the container. The beginning is the position of the first element, if any.</li><li><code>end()</code> returns an iterator that represents the end of the elements in the container. The end is the
position behind the last element. Such an iterator is also called a past-the-end iterator.</li></ul><p>Types of iterators:-</p><ol><li><strong>Forward Iterators</strong>: Support only <code>++</code> operator. Used in <code>forward_list</code>, <code>unordered_set</code>, <code>unordered_multiset</code>, <code>unordered_map</code> and <code>unordered_multimap</code>.</li><li><strong>Bidirectional Iterators</strong>: Support <code>++</code> and <code>--</code> operators. Used in <code>list</code>, <code>set</code>, <code>map</code>, <code>multiset</code> and <code>multimap</code>.</li><li><strong>Random-access Iterators</strong>: Support iterator arithmetic (<code>+,-,>,&lt;,</code>etc). Used in <code>vector</code>, <code>array</code>, <code>deque</code> and <code>string</code>.</li></ol><h3 id=algorithm>Algorithm</h3><h3 id=function-object>Function object</h3><h2 id=stl-containers>STL Containers</h2><p><img src=images/containers.png alt=Containers></p><h3 id=arrays>Arrays</h3><dl><dt>Array</dt><dd>An <em><strong>array</strong></em> is a sequence of elements with constant size.<ul><li>Ordered collection</li><li>Random access</li></ul></dd></dl><h4 id=array-provides-mathcal-o1-element-access>Array provides $\mathcal O(1)$ element access.</h4><p>This is done by using iterator arithmetic to get to any element&rsquo;s location.</p><h3 id=vectors>Vectors</h3><dl><dt>Vector</dt><dd>A <em><strong>vector</strong></em> models a dynamic array that can grow in one direction.<ul><li>Ordered collection</li><li>Random access</li><li>Dynamic storage</li></ul></dd></dl></article></main><footer id=footer></footer></div><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/syntax.css></body></html>