<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cp on Scrolls</title><link>https://adityakadoo.github.io/Scrolls/cp/</link><description>Recent content in Cp on Scrolls</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 04 Dec 2022 10:55:21 +0530</lastBuildDate><atom:link href="https://adityakadoo.github.io/Scrolls/cp/index.xml" rel="self" type="application/rss+xml"/><item><title>Algorithms</title><link>https://adityakadoo.github.io/Scrolls/cp/algorithms/</link><pubDate>Fri, 02 Sep 2022 09:46:58 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/cp/algorithms/</guid><description>Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative 1int ternary_max(int[] a, int l, int r){ 2 int res=0; 3 while(l&amp;lt;=r){ 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]&amp;lt;a[m2]){ 7 res = a[m2]; 8 l = m1+1; 9 } 10 else if(a[m1]&amp;gt;a[m2]){ 11 res = a[m1]; 12 r = m2-1; 13 } 14 else{ 15 res = a[m1]; 16 l = m1+1; 17 r = m2; 18 } 19 } 20 return res; 21} Recursive 1int ternary_max(int[] a, int l, int r){ 2 if(l==r) 3 return a[0]; 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]&amp;lt;a[m2]){ 7 return ternary_max(a,m1+1,r); 8 else if(a[m1]&amp;gt;a[m2]){ 9 return ternary_max(a,l,m2-1); 10 else 11 return ternary_max(a,m1+1,m2); 12} Proof $$n=r-l+1$$</description></item><item><title>C++ - Standard Template Library</title><link>https://adityakadoo.github.io/Scrolls/cp/cpp/</link><pubDate>Sat, 20 Aug 2022 12:27:03 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/cp/cpp/</guid><description>Basic Utilities Initializer lists 1int values[] {1, 2, 3}; 2std::vector&amp;lt;int&amp;gt; v {1, 2, 4, 8, 16}; 3std::vector&amp;lt;std::string&amp;gt; cities { 4 &amp;#34;Berlin&amp;#34;, &amp;#34;New York&amp;#34;, &amp;#34;London&amp;#34;, &amp;#34;Braunschweig&amp;#34;, &amp;#34;Cairo&amp;#34;, &amp;#34;Cologne&amp;#34; 5}; 6std::complex&amp;lt;double&amp;gt; c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container 1for (auto&amp;amp; elem : vec) { 2 elem *= 3; 3} Looping through an initializer list 1for (int i : {1, 2, 3, 4, 5}) { 2 std::cout&amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; 3} Lambda functions 1int x=0; 2int y=42; 3auto f1 = [=, &amp;amp;y] (std::string s) { 4 cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; 5 x++; // not very effective 6 y++; // super effective 7} 8auto f2 = [=] (std::string s) { 9 cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; 10 x++; // not very effective 11 y++; // not very effective 12} 13auto f3 = [&amp;amp;] (std::string s) { 14 cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; 15 x++; // super effective 16 y++; // super effective 17} Numeric Limits 1cout &amp;lt;&amp;lt; &amp;#34;max(short): &amp;#34; &amp;lt;&amp;lt; numeric_limits&amp;lt;short&amp;gt;::max() &amp;lt;&amp;lt; endl; 2cout &amp;lt;&amp;lt; &amp;#34;max(int): &amp;#34; &amp;lt;&amp;lt; numeric_limits&amp;lt;int&amp;gt;::max() &amp;lt;&amp;lt; endl; 3cout &amp;lt;&amp;lt; &amp;#34;max(long): &amp;#34; &amp;lt;&amp;lt; numeric_limits&amp;lt;long&amp;gt;::max() &amp;lt;&amp;lt; endl; Pair 1std::pair&amp;lt;T1, T2&amp;gt; p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p.</description></item></channel></rss>