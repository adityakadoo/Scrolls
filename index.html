<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.117.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=author content="Aditya Kadoo"><meta name=description content="an example site for hugo theme TeXify"><link rel=icon href=https://adityakadoo.github.io/Scrolls/favicon.ico><meta name=keywords content=" hugo  latex  theme "><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script><meta property="og:title" content="Scrolls"><meta property="og:description" content="an example site for hugo theme TeXify"><meta property="og:type" content="website"><meta property="og:url" content="https://adityakadoo.github.io/Scrolls/"><link rel=canonical href=https://adityakadoo.github.io/Scrolls/><link rel=alternate type=application/rss+xml href=https://adityakadoo.github.io/Scrolls/index.xml title=Scrolls><meta itemprop=name content="Scrolls"><meta itemprop=description content="an example site for hugo theme TeXify"><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/common.css><link media=screen rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/content.css><title>Scrolls</title><meta name=twitter:card content="summary"><meta name=twitter:title content="Scrolls"><meta name=twitter:description content="an example site for hugo theme TeXify"><link rel=stylesheet href=https://adityakadoo.github.io/Scrolls/css/index.css></head><body><div id=wrapper><header id=header><h1><a href=https://adityakadoo.github.io/Scrolls/>Scrolls</a></h1><nav><span class=nav-bar-item><a class=link href></a></span></nav><p></p></header><main id=main class=index><div class=post><h2><a href=https://adityakadoo.github.io/Scrolls/courses/ai_ml/>Artificial Intelligence and Machine Learning</a>
<time>2022-09-05</time></h2><div><b>Keywords:</b>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/machine-learning>#Machine-Learning</a>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/computer-science>#Computer-Science</a></div><div class=content>Probability Basic Terms Sample Space Sample Space $(S)$ The set of all possible outcomes of an experiment. $$ P(S)=1,P(\empty)=0 $$ Probability Distribution Probability Distribution $(p)$ A function that gives the probabilities of occurence of different possible outcomes of an experiment. $$ p:S\rightarrow[0,1]\\ \sum_{x\in S}p(x)=1 $$ Event Event $(E)$ A set of outcomes of an experiement i.e. a subset of the sample space. $$ E\sube S $$ Probability of an Event Probability of an event $P(E)$ The likelihood of an event happening.</div></div><div class=post><h2><a href=https://adityakadoo.github.io/Scrolls/cp/algorithms/>Algorithms</a>
<time>2022-09-02</time></h2><div><b>Keywords:</b>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/computer-science>#Computer-Science</a>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/math>#Math</a></div><div class=content>Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative int ternary_max(int[] a, int l, int r){ int res=0; while(l&lt;=r){ int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]&lt;a[m2]){ res = a[m2]; l = m1+1; } else if(a[m1]>a[m2]){ res = a[m1]; r = m2-1; } else{ res = a[m1]; l = m1+1; r = m2; } } return res; } Recursive int ternary_max(int[] a, int l, int r){ if(l==r) return a[0]; int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]&lt;a[m2]){ return ternary_max(a,m1+1,r); else if(a[m1]>a[m2]){ return ternary_max(a,l,m2-1); else return ternary_max(a,m1+1,m2); } Proof $$n=r-l+1$$</div></div><div class=post><h2><a href=https://adityakadoo.github.io/Scrolls/courses/natural_language_processing/>Natural Language Processing</a>
<time>2022-08-24</time></h2><div><b>Keywords:</b>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/computer-science>#Computer-Science</a>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/machine-learning>#Machine-Learning</a></div><div class=content>Part of Speech Tagging HMM-based Tagging Parameters Input: A sequence of words and labels Output: A sequence of labels for every word Penn tag-set is generally used for POS tagging in english language.
Hidden Markov Model There are 2 kinds of probabilities:
Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$. Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$.</div></div><div class=post><h2><a href=https://adityakadoo.github.io/Scrolls/cp/cpp/>C++ - Standard Template Library</a>
<time>2022-08-20</time></h2><div><b>Keywords:</b>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/programming-languages>#Programming-Languages</a>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/computer-science>#Computer-Science</a></div><div class=content>Basic Utilities Initializer lists int values[] {1, 2, 3}; std::vector&lt;int> v {1, 2, 4, 8, 16}; std::vector&lt;std::string> cities { "Berlin", "New York", "London", "Braunschweig", "Cairo", "Cologne" }; std::complex&lt;double> c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container for (auto& elem : vec) { elem *= 3; } Looping through an initializer list for (int i : {1, 2, 3, 4, 5}) { std::cout&lt;&lt; i &lt;&lt; std::endl; } Lambda functions int x=0; int y=42; auto f1 = [=, &amp;y] (std::string s) { cout&lt;&lt;s&lt;&lt;"\n"; x++; // not very effective y++; // super effective } auto f2 = [=] (std::string s) { cout&lt;&lt;s&lt;&lt;"\n"; x++; // not very effective y++; // not very effective } auto f3 = [&] (std::string s) { cout&lt;&lt;s&lt;&lt;"\n"; x++; // super effective y++; // super effective } Numeric Limits cout &lt;&lt; "max(short): " &lt;&lt; numeric_limits&lt;short>::max() &lt;&lt; endl; cout &lt;&lt; "max(int): " &lt;&lt; numeric_limits&lt;int>::max() &lt;&lt; endl; cout &lt;&lt; "max(long): " &lt;&lt; numeric_limits&lt;long>::max() &lt;&lt; endl; Pair std::pair&lt;T1, T2> p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p.</div></div><div class=post><h2><a href=https://adityakadoo.github.io/Scrolls/courses/automata_theory/>Automata Theory</a>
<time>2022-08-19</time></h2><div><b>Keywords:</b>
<a class=link href=https://adityakadoo.github.io/Scrolls/tags/computer-science>#Computer-Science</a></div><div class=content>Resources Hopcrot-Motwani-Ullman Central Concepts Alphabets Alphabet $ (\Sigma) $ An alphabet is a finite nonempty set of symbols. $ \Sigma= \{1, 0\} $ $ \Sigma = \{a,b,&mldr;,z\}$ Strings String $(w)$ A string is a finite sequence of symbols chosen from $ \Sigma $. Empty String $(\epsilon)$ The empty string is a string with zero symbols. Length of a string $|w|=\#$ Symbols in $w$ $|\epsilon|=0$
Power of Alphabets $\Sigma^k=\{w:|w|=k\}$ $\Sigma^+=\Sigma^1\cup\Sigma^2\cup&mldr;$ $\Sigma^*=\Sigma^+\cup\{\epsilon\}$ $\Sigma^0= \{\epsilon\}$</div></div><div class=paginator><a></a>
<a class=link href=/Scrolls/page/2/>next â†’</a></div></main><footer id=footer></footer></div></body></html>