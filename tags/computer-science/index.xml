<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer-Science on Scrolls</title><link>https://adityakadoo.github.io/Scrolls/tags/computer-science/</link><description>Recent content in Computer-Science on Scrolls</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 24 Aug 2022 09:49:01 +0530</lastBuildDate><atom:link href="https://adityakadoo.github.io/Scrolls/tags/computer-science/index.xml" rel="self" type="application/rss+xml"/><item><title>Natural Language Processing</title><link>https://adityakadoo.github.io/Scrolls/courses/natural_language_processing/</link><pubDate>Wed, 24 Aug 2022 09:49:01 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/courses/natural_language_processing/</guid><description>Part of Speech Tagging Viterbi Algorithm Parameters Input: A sequence of words and labels Output: A sequence of labels for every word Penn tag-set is generally used for POS tagging in english language.
Hidden Markov Model There are 2 kinds of probabilities:
Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$. Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$.</description></item><item><title>C++</title><link>https://adityakadoo.github.io/Scrolls/cp/cpp/</link><pubDate>Sat, 20 Aug 2022 12:27:03 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/cp/cpp/</guid><description>Basic Utilities Initializer lists int values[] {1, 2, 3}; std::vector&amp;lt;int&amp;gt; v {1, 2, 4, 8, 16}; std::vector&amp;lt;std::string&amp;gt; cities { &amp;#34;Berlin&amp;#34;, &amp;#34;New York&amp;#34;, &amp;#34;London&amp;#34;, &amp;#34;Braunschweig&amp;#34;, &amp;#34;Cairo&amp;#34;, &amp;#34;Cologne&amp;#34; }; std::complex&amp;lt;double&amp;gt; c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container for (auto&amp;amp; elem : vec) { elem *= 3; } Looping through an initializer list for (int i : {1, 2, 3, 4, 5}) { std::cout&amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } Lambda functions int x=0; int y=42; auto f1 = [=, &amp;amp;y] (std::string s) { cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; x++; // not very effective y++; // super effective } auto f2 = [=] (std::string s) { cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; x++; // not very effective y++; // not very effective } auto f3 = [&amp;amp;] (std::string s) { cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; x++; // super effective y++; // super effective } STL Data types Pair std::pair&amp;lt;T1, T2&amp;gt; p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p.</description></item><item><title>Automata Theory</title><link>https://adityakadoo.github.io/Scrolls/courses/automata_theory/</link><pubDate>Fri, 19 Aug 2022 17:00:34 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/courses/automata_theory/</guid><description>Resources Hopcrot-Motwani-Ullman Central Concepts Alphabets Alphabet $ (\Sigma) $ An alphabet is a finite nonempty set of symbols. $ \Sigma= \{1, 0\} $ $ \Sigma = \{a,b,&amp;hellip;,z\}$ Strings String $(w)$ A string is a finite sequence of symbols chosen from $ \Sigma $. Empty String Empty String $(\epsilon)$ The empty string is a string with zero symbols. Length of a String $|w|=\#$ Symbols in $w$
$|\epsilon|=0$
Powers of Alphabets $\Sigma^k=\{w:|w|=k\}$ $\Sigma^+=\Sigma^1\cup\Sigma^2\cup&amp;hellip;$ $\Sigma^*=\Sigma^+\cup\{\epsilon\}$ $\Sigma^0= \{\epsilon\}$</description></item><item><title>Operating Systems</title><link>https://adityakadoo.github.io/Scrolls/courses/operating_systems/</link><pubDate>Fri, 19 Aug 2022 10:31:05 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/courses/operating_systems/</guid><description>Resources Operating Systems - Three Easy Pieces Introduction to OS Main objectives of OS include:-
CPU Virtualization : Making using the processor easy. Memory Virtualization : Making storage in memory easy. Concurrency : Ensuring correctness when multiple programs run together. Persistence : Ensuring permanent memory does not get erased and stays organised. Design Goals : Abstractions, performance, isolation, reliability, energy-efficiency Virtualization Abstraction : Process The abstraction provided by the OS of a running program is called a process.</description></item></channel></rss>