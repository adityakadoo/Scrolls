<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer-Science on Scrolls</title><link>https://adityakadoo.github.io/Scrolls/tags/computer-science/</link><description>Recent content in Computer-Science on Scrolls</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 05 Sep 2022 06:52:35 +0530</lastBuildDate><atom:link href="https://adityakadoo.github.io/Scrolls/tags/computer-science/index.xml" rel="self" type="application/rss+xml"/><item><title>Artificial Intelligence and Machine Learning</title><link>https://adityakadoo.github.io/Scrolls/courses/ai_ml/</link><pubDate>Mon, 05 Sep 2022 06:52:35 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/courses/ai_ml/</guid><description>Probability Basic Terms Sample Space Sample Space $(S)$ The set of all possible outcomes of an experiment. $$ P(S)=1,P(\empty)=0 $$ Probability Distribution Probability Distribution $(p)$ A function that gives the probabilities of occurence of different possible outcomes of an experiment. $$ p:S\rightarrow[0,1]\\ \sum_{x\in S}p(x)=1 $$ Event Event $(E)$ A set of outcomes of an experiement i.e. a subset of the sample space. $$ E\sube S $$ Probability of an Event Probability of an event $P(E)$ The likelihood of an event happening.</description></item><item><title>Algorithms</title><link>https://adityakadoo.github.io/Scrolls/cp/algorithms/</link><pubDate>Fri, 02 Sep 2022 09:46:58 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/cp/algorithms/</guid><description>Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative 1int ternary_max(int[] a, int l, int r){ 2 int res=0; 3 while(l&amp;lt;=r){ 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]&amp;lt;a[m2]){ 7 res = a[m2]; 8 l = m1+1; 9 } 10 else if(a[m1]&amp;gt;a[m2]){ 11 res = a[m1]; 12 r = m2-1; 13 } 14 else{ 15 res = a[m1]; 16 l = m1+1; 17 r = m2; 18 } 19 } 20 return res; 21} Recursive 1int ternary_max(int[] a, int l, int r){ 2 if(l==r) 3 return a[0]; 4 int m1 = l+(r-l)/3; 5 int m2 = r-(r-l)/3; 6 if(a[m1]&amp;lt;a[m2]){ 7 return ternary_max(a,m1+1,r); 8 else if(a[m1]&amp;gt;a[m2]){ 9 return ternary_max(a,l,m2-1); 10 else 11 return ternary_max(a,m1+1,m2); 12} Proof $$n=r-l+1$$</description></item><item><title>Natural Language Processing</title><link>https://adityakadoo.github.io/Scrolls/courses/natural_language_processing/</link><pubDate>Wed, 24 Aug 2022 09:49:01 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/courses/natural_language_processing/</guid><description>Part of Speech Tagging HMM-based Tagging Parameters Input: A sequence of words and labels Output: A sequence of labels for every word Penn tag-set is generally used for POS tagging in english language.
Hidden Markov Model There are 2 kinds of probabilities:
Bigram Probabilities $(P(t_1|t_0))$ : Probability of current word being tag $t_1$ when previous word was tagged $t_0$. Lexical Probabilities $(P(w|t))$: Probability of word $w$ given it is tagged $t$.</description></item><item><title>C++ - Standard Template Library</title><link>https://adityakadoo.github.io/Scrolls/cp/cpp/</link><pubDate>Sat, 20 Aug 2022 12:27:03 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/cp/cpp/</guid><description>Basic Utilities Initializer lists 1int values[] {1, 2, 3}; 2std::vector&amp;lt;int&amp;gt; v {1, 2, 4, 8, 16}; 3std::vector&amp;lt;std::string&amp;gt; cities { 4 &amp;#34;Berlin&amp;#34;, &amp;#34;New York&amp;#34;, &amp;#34;London&amp;#34;, &amp;#34;Braunschweig&amp;#34;, &amp;#34;Cairo&amp;#34;, &amp;#34;Cologne&amp;#34; 5}; 6std::complex&amp;lt;double&amp;gt; c{4.0,3.0}; // equivalent to c(4.0,3.0) Range-based for loops Looping through a container 1for (auto&amp;amp; elem : vec) { 2 elem *= 3; 3} Looping through an initializer list 1for (int i : {1, 2, 3, 4, 5}) { 2 std::cout&amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; 3} Lambda functions 1int x=0; 2int y=42; 3auto f1 = [=, &amp;amp;y] (std::string s) { 4 cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; 5 x++; // not very effective 6 y++; // super effective 7} 8auto f2 = [=] (std::string s) { 9 cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; 10 x++; // not very effective 11 y++; // not very effective 12} 13auto f3 = [&amp;amp;] (std::string s) { 14 cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; 15 x++; // super effective 16 y++; // super effective 17} Numeric Limits 1cout &amp;lt;&amp;lt; &amp;#34;max(short): &amp;#34; &amp;lt;&amp;lt; numeric_limits&amp;lt;short&amp;gt;::max() &amp;lt;&amp;lt; endl; 2cout &amp;lt;&amp;lt; &amp;#34;max(int): &amp;#34; &amp;lt;&amp;lt; numeric_limits&amp;lt;int&amp;gt;::max() &amp;lt;&amp;lt; endl; 3cout &amp;lt;&amp;lt; &amp;#34;max(long): &amp;#34; &amp;lt;&amp;lt; numeric_limits&amp;lt;long&amp;gt;::max() &amp;lt;&amp;lt; endl; Pair 1std::pair&amp;lt;T1, T2&amp;gt; p(e1,e2); Operation Effect Complexity make_pair(e1,e2) Returns a pair using types and values of e1 and e2 $\mathcal{O}(1)$ p.</description></item><item><title>Automata Theory</title><link>https://adityakadoo.github.io/Scrolls/courses/automata_theory/</link><pubDate>Fri, 19 Aug 2022 17:00:34 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/courses/automata_theory/</guid><description>Resources Hopcrot-Motwani-Ullman Central Concepts Alphabets Alphabet $ (\Sigma) $ An alphabet is a finite nonempty set of symbols. $ \Sigma= \{1, 0\} $ $ \Sigma = \{a,b,&amp;hellip;,z\}$ Strings String $(w)$ A string is a finite sequence of symbols chosen from $ \Sigma $. Empty String $(\epsilon)$ The empty string is a string with zero symbols. Length of a string $|w|=\#$ Symbols in $w$ $|\epsilon|=0$
Power of Alphabets $\Sigma^k=\{w:|w|=k\}$ $\Sigma^+=\Sigma^1\cup\Sigma^2\cup&amp;hellip;$ $\Sigma^*=\Sigma^+\cup\{\epsilon\}$ $\Sigma^0= \{\epsilon\}$</description></item><item><title>Operating Systems</title><link>https://adityakadoo.github.io/Scrolls/courses/operating_systems/</link><pubDate>Fri, 19 Aug 2022 10:31:05 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/courses/operating_systems/</guid><description>Resources Operating Systems - Three Easy Pieces Introduction to OS Main objectives of OS include:-
CPU Virtualization : Making using the processor easy. Memory Virtualization : Making storage in memory easy. Concurrency : Ensuring correctness when multiple programs run together. Persistence : Ensuring permanent memory does not get erased and stays organised. Design Goals : Abstractions, performance, isolation, reliability, energy-efficiency CPU Virtualization Abstraction : Process The abstraction provided by the OS of a running program is called a process.</description></item></channel></rss>