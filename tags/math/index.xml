<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Scrolls</title><link>https://adityakadoo.github.io/Scrolls/tags/math/</link><description>Recent content in Math on Scrolls</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 02 Sep 2022 09:46:58 +0530</lastBuildDate><atom:link href="https://adityakadoo.github.io/Scrolls/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>Algorithms</title><link>https://adityakadoo.github.io/Scrolls/cp/algorithms/</link><pubDate>Fri, 02 Sep 2022 09:46:58 +0530</pubDate><guid>https://adityakadoo.github.io/Scrolls/cp/algorithms/</guid><description>Numerical Methods (3) Ternary Search We are given a funtion $f(x)$ which is unimodal on an interval $[l,r]$. This means it has one of the following two behaviours:
The function strictly increases first, reaches maximum and then strictly decreases. The function strictly decreases first, reaches minimum and then strictly increases. Here we assume the first case and find the maximum of $f(x)$ on the interval $[l,r]$.
Implementation Iterative int ternary_max(int[] a, int l, int r){ int res=0; while(l&amp;lt;=r){ int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]&amp;lt;a[m2]){ res = a[m2]; l = m1+1; } else if(a[m1]&amp;gt;a[m2]){ res = a[m1]; r = m2-1; } else{ res = a[m1]; l = m1+1; r = m2; } } return res; } Recursive int ternary_max(int[] a, int l, int r){ if(l==r) return a[0]; int m1 = l+(r-l)/3; int m2 = r-(r-l)/3; if(a[m1]&amp;lt;a[m2]){ return ternary_max(a,m1+1,r); else if(a[m1]&amp;gt;a[m2]){ return ternary_max(a,l,m2-1); else return ternary_max(a,m1+1,m2); } Proof $$n=r-l+1$$</description></item></channel></rss>